{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"graphql-php \u00b6 About GraphQL \u00b6 GraphQL is a modern way to build HTTP APIs consumed by the web and mobile clients. It is intended to be an alternative to REST and SOAP APIs (even for existing applications ). GraphQL itself is a specification designed by Facebook engineers. Various implementations of this specification were written in different languages and environments . Great overview of GraphQL features and benefits is presented on the official website . All of them equally apply to this PHP implementation. About graphql-php \u00b6 graphql-php is a feature-complete implementation of GraphQL specification in PHP. It was originally inspired by reference JavaScript implementation published by Facebook. This library is a thin wrapper around your existing data layer and business logic. It doesn't dictate how these layers are implemented or which storage engines are used. Instead, it provides tools for creating rich API for your existing app. Library features include: Primitives to express your app as a Type System Validation and introspection of this Type System (for compatibility with tools like GraphiQL ) Parsing, validating and executing GraphQL queries against this Type System Rich error reporting , including query validation and execution errors Optional tools for parsing schema definition language Tools for batching requests to backend storage Async PHP platforms support via promises Standard HTTP server Also, several complementary tools are available which provide integrations with existing PHP frameworks, add support for Relay, etc. Current Status \u00b6 The first version of this library (v0.1) was released on August 10th 2015. The current version supports all features described by GraphQL specification as well as some experimental features like schema definition language and schema printer . Ready for real-world usage. GitHub \u00b6 Project source code is hosted on GitHub .","title":"About"},{"location":"#graphql-php","text":"","title":"graphql-php"},{"location":"#about-graphql","text":"GraphQL is a modern way to build HTTP APIs consumed by the web and mobile clients. It is intended to be an alternative to REST and SOAP APIs (even for existing applications ). GraphQL itself is a specification designed by Facebook engineers. Various implementations of this specification were written in different languages and environments . Great overview of GraphQL features and benefits is presented on the official website . All of them equally apply to this PHP implementation.","title":"About GraphQL"},{"location":"#about-graphql-php","text":"graphql-php is a feature-complete implementation of GraphQL specification in PHP. It was originally inspired by reference JavaScript implementation published by Facebook. This library is a thin wrapper around your existing data layer and business logic. It doesn't dictate how these layers are implemented or which storage engines are used. Instead, it provides tools for creating rich API for your existing app. Library features include: Primitives to express your app as a Type System Validation and introspection of this Type System (for compatibility with tools like GraphiQL ) Parsing, validating and executing GraphQL queries against this Type System Rich error reporting , including query validation and execution errors Optional tools for parsing schema definition language Tools for batching requests to backend storage Async PHP platforms support via promises Standard HTTP server Also, several complementary tools are available which provide integrations with existing PHP frameworks, add support for Relay, etc.","title":"About graphql-php"},{"location":"#current-status","text":"The first version of this library (v0.1) was released on August 10th 2015. The current version supports all features described by GraphQL specification as well as some experimental features like schema definition language and schema printer . Ready for real-world usage.","title":"Current Status"},{"location":"#github","text":"Project source code is hosted on GitHub .","title":"GitHub"},{"location":"class-reference/","text":"GraphQL\\GraphQL \u00b6 This is the primary facade for fulfilling GraphQL operations. See related documentation . @phpstan-import-type FieldResolver from Executor GraphQL\\GraphQL Methods \u00b6 /** * Executes graphql query. * * More sophisticated GraphQL servers, such as those which persist queries, * may wish to separate the validation and execution phases to a static time * tooling step, and a server runtime step. * * Available options: * * schema: * The GraphQL type system to use when validating and executing a query. * source: * A GraphQL language formatted string representing the requested operation. * rootValue: * The value provided as the first argument to resolver functions on the top * level type (e.g. the query object type). * contextValue: * The context value is provided as an argument to resolver functions after * field arguments. It is used to pass shared information useful at any point * during executing this query, for example the currently logged in user and * connections to databases or other services. * variableValues: * A mapping of variable name to runtime value to use for all variables * defined in the requestString. * operationName: * The name of the operation to use if requestString contains multiple * possible operations. Can be omitted if requestString contains only * one operation. * fieldResolver: * A resolver function to use when one is not provided by the schema. * If not provided, the default field resolver is used (which looks for a * value on the source value with the field's name). * validationRules: * A set of rules for query validation step. Default value is all available rules. * Empty array would allow to skip query validation (may be convenient for persisted * queries which are validated before persisting and assumed valid during execution) * * @param string|DocumentNode $source * @param mixed $rootValue * @param mixed $contextValue * @param array<string, mixed>|null $variableValues * @param array<ValidationRule>|null $validationRules * * @api */ static function executeQuery( GraphQL\\Type\\Schema $schema, $source, $rootValue = null, $contextValue = null, ?array $variableValues = null, ?string $operationName = null, ?callable $fieldResolver = null, ?array $validationRules = null ): GraphQL\\Executor\\ExecutionResult /** * Same as executeQuery(), but requires PromiseAdapter and always returns a Promise. * Useful for Async PHP platforms. * * @param string|DocumentNode $source * @param mixed $rootValue * @param mixed $context * @param array<string, mixed>|null $variableValues * @param array<ValidationRule>|null $validationRules * * @api */ static function promiseToExecute( GraphQL\\Executor\\Promise\\PromiseAdapter $promiseAdapter, GraphQL\\Type\\Schema $schema, $source, $rootValue = null, $context = null, ?array $variableValues = null, ?string $operationName = null, ?callable $fieldResolver = null, ?array $validationRules = null ): GraphQL\\Executor\\Promise\\Promise /** * Returns directives defined in GraphQL spec. * * @return array<string, Directive> * * @api */ static function getStandardDirectives(): array /** * Returns types defined in GraphQL spec. * * @return array<string, ScalarType> * * @api */ static function getStandardTypes(): array /** * Replaces standard types with types from this list (matching by name). * * Standard types not listed here remain untouched. * * @param array<string, ScalarType> $types * * @api */ static function overrideStandardTypes(array $types): void /** * Returns standard validation rules implementing GraphQL spec. * * @return array<class-string<ValidationRule>, ValidationRule> * * @api */ static function getStandardValidationRules(): array /** * Set default resolver implementation. * * @phpstan-param FieldResolver $fn * * @api */ static function setDefaultFieldResolver(callable $fn): void GraphQL\\Type\\Definition\\Type \u00b6 Registry of standard GraphQL types and base class for all other types. GraphQL\\Type\\Definition\\Type Methods \u00b6 /** * @api */ static function id(): GraphQL\\Type\\Definition\\ScalarType /** * @api */ static function string(): GraphQL\\Type\\Definition\\ScalarType /** * @api */ static function boolean(): GraphQL\\Type\\Definition\\ScalarType /** * @api */ static function int(): GraphQL\\Type\\Definition\\ScalarType /** * @api */ static function float(): GraphQL\\Type\\Definition\\ScalarType /** * @template T of Type * * @param T|callable():T $type * * @return ListOfType<T> * * @api */ static function listOf($type): GraphQL\\Type\\Definition\\ListOfType /** * @param (NullableType&Type)|callable():(NullableType&Type) $type * * @api */ static function nonNull($type): GraphQL\\Type\\Definition\\NonNull /** * @param mixed $type * * @api */ static function isInputType($type): bool /** * @return (Type&NamedType)|null * * @api */ static function getNamedType(?GraphQL\\Type\\Definition\\Type $type): ?GraphQL\\Type\\Definition\\Type /** * @param mixed $type * * @api */ static function isOutputType($type): bool /** * @param mixed $type * * @api */ static function isLeafType($type): bool /** * @param mixed $type * * @api */ static function isCompositeType($type): bool /** * @param mixed $type * * @api */ static function isAbstractType($type): bool /** * @return Type&NullableType * * @api */ static function getNullableType(GraphQL\\Type\\Definition\\Type $type): GraphQL\\Type\\Definition\\Type GraphQL\\Type\\Definition\\ResolveInfo \u00b6 Structure containing information useful for field resolution process. Passed as 4th argument to every field resolver. See docs on field resolving (data fetching) . @phpstan-import-type QueryPlanOptions from QueryPlan @phpstan-type Path array GraphQL\\Type\\Definition\\ResolveInfo Props \u00b6 /** * The definition of the field being resolved. * * @api */ public $fieldDefinition; /** * The name of the field being resolved. * * @api */ public $fieldName; /** * Expected return type of the field being resolved. * * @api */ public $returnType; /** * AST of all nodes referencing this field in the query. * * @api * * @var ArrayObject<int, FieldNode> */ public $fieldNodes; /** * Parent type of the field being resolved. * * @api */ public $parentType; /** * Path to this field from the very root value. * * @api * * @var array<int, string|int> * @phpstan-var Path */ public $path; /** * Instance of a schema used for execution. * * @api */ public $schema; /** * AST of all fragments defined in query. * * @api * * @var array<string, FragmentDefinitionNode> */ public $fragments; /** * Root value passed to query execution. * * @api * * @var mixed */ public $rootValue; /** * AST of operation definition node (query, mutation). * * @api */ public $operation; /** * Array of variables passed to query execution. * * @api * * @var array<string, mixed> */ public $variableValues; GraphQL\\Type\\Definition\\ResolveInfo Methods \u00b6 /** * Helper method that returns names of all fields selected in query for * $this->fieldName up to $depth levels. * * Example: * query MyQuery{ * { * root { * id, * nested { * nested1 * nested2 { * nested3 * } * } * } * } * * Given this ResolveInfo instance is a part of \"root\" field resolution, and $depth === 1, * method will return: * [ * 'id' => true, * 'nested' => [ * nested1 => true, * nested2 => true * ] * ] * * Warning: this method it is a naive implementation which does not take into account * conditional typed fragments. So use it with care for fields of interface and union types. * * @param int $depth How many levels to include in output * * @return array<string, mixed> * * @api */ function getFieldSelection(int $depth = 0): array GraphQL\\Language\\DirectiveLocation \u00b6 Enumeration of available directive locations. GraphQL\\Language\\DirectiveLocation Constants \u00b6 const QUERY = 'QUERY'; const MUTATION = 'MUTATION'; const SUBSCRIPTION = 'SUBSCRIPTION'; const FIELD = 'FIELD'; const FRAGMENT_DEFINITION = 'FRAGMENT_DEFINITION'; const FRAGMENT_SPREAD = 'FRAGMENT_SPREAD'; const INLINE_FRAGMENT = 'INLINE_FRAGMENT'; const VARIABLE_DEFINITION = 'VARIABLE_DEFINITION'; const EXECUTABLE_LOCATIONS = [ 'QUERY' => 'QUERY', 'MUTATION' => 'MUTATION', 'SUBSCRIPTION' => 'SUBSCRIPTION', 'FIELD' => 'FIELD', 'FRAGMENT_DEFINITION' => 'FRAGMENT_DEFINITION', 'FRAGMENT_SPREAD' => 'FRAGMENT_SPREAD', 'INLINE_FRAGMENT' => 'INLINE_FRAGMENT', 'VARIABLE_DEFINITION' => 'VARIABLE_DEFINITION', ]; const SCHEMA = 'SCHEMA'; const SCALAR = 'SCALAR'; const OBJECT = 'OBJECT'; const FIELD_DEFINITION = 'FIELD_DEFINITION'; const ARGUMENT_DEFINITION = 'ARGUMENT_DEFINITION'; const IFACE = 'INTERFACE'; const UNION = 'UNION'; const ENUM = 'ENUM'; const ENUM_VALUE = 'ENUM_VALUE'; const INPUT_OBJECT = 'INPUT_OBJECT'; const INPUT_FIELD_DEFINITION = 'INPUT_FIELD_DEFINITION'; const TYPE_SYSTEM_LOCATIONS = [ 'SCHEMA' => 'SCHEMA', 'SCALAR' => 'SCALAR', 'OBJECT' => 'OBJECT', 'FIELD_DEFINITION' => 'FIELD_DEFINITION', 'ARGUMENT_DEFINITION' => 'ARGUMENT_DEFINITION', 'INTERFACE' => 'INTERFACE', 'UNION' => 'UNION', 'ENUM' => 'ENUM', 'ENUM_VALUE' => 'ENUM_VALUE', 'INPUT_OBJECT' => 'INPUT_OBJECT', 'INPUT_FIELD_DEFINITION' => 'INPUT_FIELD_DEFINITION', ]; const LOCATIONS = [ 'QUERY' => 'QUERY', 'MUTATION' => 'MUTATION', 'SUBSCRIPTION' => 'SUBSCRIPTION', 'FIELD' => 'FIELD', 'FRAGMENT_DEFINITION' => 'FRAGMENT_DEFINITION', 'FRAGMENT_SPREAD' => 'FRAGMENT_SPREAD', 'INLINE_FRAGMENT' => 'INLINE_FRAGMENT', 'VARIABLE_DEFINITION' => 'VARIABLE_DEFINITION', 'SCHEMA' => 'SCHEMA', 'SCALAR' => 'SCALAR', 'OBJECT' => 'OBJECT', 'FIELD_DEFINITION' => 'FIELD_DEFINITION', 'ARGUMENT_DEFINITION' => 'ARGUMENT_DEFINITION', 'INTERFACE' => 'INTERFACE', 'UNION' => 'UNION', 'ENUM' => 'ENUM', 'ENUM_VALUE' => 'ENUM_VALUE', 'INPUT_OBJECT' => 'INPUT_OBJECT', 'INPUT_FIELD_DEFINITION' => 'INPUT_FIELD_DEFINITION', ]; GraphQL\\Type\\SchemaConfig \u00b6 Configuration options for schema construction. The options accepted by the create method are described in the schema definition docs . Usage example: $config = SchemaConfig::create() ->setQuery($myQueryType) ->setTypeLoader($myTypeLoader); $schema = new Schema($config); @see Type, NamedType @phpstan-type TypeLoader callable(string $typeName):((Type&NamedType)|null) @phpstan-type Types array |callable():array GraphQL\\Type\\SchemaConfig Methods \u00b6 /** * Converts an array of options to instance of SchemaConfig * (or just returns empty config when array is not passed). * * @param array<string, mixed> $options * * @api */ static function create(array $options = []): self /** * @api */ function getQuery(): ?GraphQL\\Type\\Definition\\ObjectType /** * @api */ function setQuery(?GraphQL\\Type\\Definition\\ObjectType $query): self /** * @api */ function getMutation(): ?GraphQL\\Type\\Definition\\ObjectType /** * @api */ function setMutation(?GraphQL\\Type\\Definition\\ObjectType $mutation): self /** * @api */ function getSubscription(): ?GraphQL\\Type\\Definition\\ObjectType /** * @api */ function setSubscription(?GraphQL\\Type\\Definition\\ObjectType $subscription): self /** * @return array|callable * @phpstan-return Types * * @api */ function getTypes() /** * @param array|callable $types * @phpstan-param Types $types * * @api */ function setTypes($types): self /** * @return array<Directive>|null * * @api */ function getDirectives(): ?array /** * @param array<Directive>|null $directives * * @api */ function setDirectives(?array $directives): self /** * @return callable|null $typeLoader * @phpstan-return TypeLoader|null $typeLoader * * @api */ function getTypeLoader(): ?callable /** * @phpstan-param TypeLoader|null $typeLoader * * @api */ function setTypeLoader(?callable $typeLoader): self GraphQL\\Type\\Schema \u00b6 Schema Definition (see schema definition docs ). A Schema is created by supplying the root types of each type of operation: query, mutation (optional) and subscription (optional). A schema definition is then supplied to the validator and executor. Usage Example: $schema = new GraphQL\\Type\\Schema([ 'query' => $MyAppQueryRootType, 'mutation' => $MyAppMutationRootType, ]); Or using Schema Config instance: $config = GraphQL\\Type\\SchemaConfig::create() ->setQuery($MyAppQueryRootType) ->setMutation($MyAppMutationRootType); $schema = new GraphQL\\Type\\Schema($config); GraphQL\\Type\\Schema Methods \u00b6 /** * @param SchemaConfig|array<string, mixed> $config * * @api */ function __construct($config) /** * Returns all types in this schema. * * This operation requires a full schema scan. Do not use in production environment. * * @return array<string, Type&NamedType> Keys represent type names, values are instances of corresponding type definitions * * @api */ function getTypeMap(): array /** * Returns a list of directives supported by this schema. * * @return array<Directive> * * @api */ function getDirectives(): array /** * Returns root query type. * * @api */ function getQueryType(): ?GraphQL\\Type\\Definition\\ObjectType /** * Returns root mutation type. * * @api */ function getMutationType(): ?GraphQL\\Type\\Definition\\ObjectType /** * Returns schema subscription. * * @api */ function getSubscriptionType(): ?GraphQL\\Type\\Definition\\ObjectType /** * @api */ function getConfig(): GraphQL\\Type\\SchemaConfig /** * Returns a type by name. * * @return (Type&NamedType)|null * * @api */ function getType(string $name): ?GraphQL\\Type\\Definition\\Type /** * Returns all possible concrete types for given abstract type * (implementations for interfaces and members of union type for unions). * * This operation requires full schema scan. Do not use in production environment. * * @param AbstractType&Type $abstractType * * @return array<ObjectType> * * @api */ function getPossibleTypes(GraphQL\\Type\\Definition\\AbstractType $abstractType): array /** * Returns all types that implement a given interface type. * * This operation requires full schema scan. Do not use in production environment. * * @api */ function getImplementations(GraphQL\\Type\\Definition\\InterfaceType $abstractType): GraphQL\\Utils\\InterfaceImplementations /** * Returns true if the given type is a sub type of the given abstract type. * * @param AbstractType&Type $abstractType * @param ImplementingType&Type $maybeSubType * * @api */ function isSubType( GraphQL\\Type\\Definition\\AbstractType $abstractType, GraphQL\\Type\\Definition\\ImplementingType $maybeSubType ): bool /** * Returns instance of directive by name. * * @api */ function getDirective(string $name): ?GraphQL\\Type\\Definition\\Directive /** * Throws if the schema is not valid. * * This operation requires a full schema scan. Do not use in production environment. * * @throws InvariantViolation * * @api */ function assertValid(): void /** * Validate the schema and return any errors. * * This operation requires a full schema scan. Do not use in production environment. * * @return array<int, Error> * * @api */ function validate(): array GraphQL\\Language\\Parser \u00b6 Parses string containing GraphQL query language or schema definition language to Abstract Syntax Tree. @phpstan-type ParserOptions array{ noLocation?: bool, allowLegacySDLEmptyFields?: bool, allowLegacySDLImplementsInterfaces?: bool, experimentalFragmentVariables?: bool } noLocation: (By default, the parser creates AST nodes that know the location in the source that they correspond to. This configuration flag disables that behavior for performance or testing.) allowLegacySDLEmptyFields: If enabled, the parser will parse empty fields sets in the Schema Definition Language. Otherwise, the parser will follow the current specification. This option is provided to ease adoption of the final SDL specification and will be removed in a future major release. allowLegacySDLImplementsInterfaces: If enabled, the parser will parse implemented interfaces with no & character between each interface. Otherwise, the parser will follow the current specification. This option is provided to ease adoption of the final SDL specification and will be removed in a future major release. experimentalFragmentVariables: (If enabled, the parser will understand and parse variable definitions contained in a fragment definition. They'll be represented in the variableDefinitions field of the FragmentDefinitionNode. The syntax is identical to normal, query-defined variables. For example: fragment A($var: Boolean = false) on T { ... } Note: this feature is experimental and may change or be removed in the future.) Those magic functions allow partial parsing: @method static NameNode name(Source|string $source, bool[] $options = []) @method static DocumentNode document(Source|string $source, bool[] $options = []) @method static ExecutableDefinitionNode|TypeSystemDefinitionNode definition(Source|string $source, bool[] $options = []) @method static ExecutableDefinitionNode executableDefinition(Source|string $source, bool[] $options = []) @method static OperationDefinitionNode operationDefinition(Source|string $source, bool[] $options = []) @method static string operationType(Source|string $source, bool[] $options = []) @method static NodeList variableDefinitions(Source|string $source, bool[] $options = []) @method static VariableDefinitionNode variableDefinition(Source|string $source, bool[] $options = []) @method static VariableNode variable(Source|string $source, bool[] $options = []) @method static SelectionSetNode selectionSet(Source|string $source, bool[] $options = []) @method static mixed selection(Source|string $source, bool[] $options = []) @method static FieldNode field(Source|string $source, bool[] $options = []) @method static NodeList arguments(Source|string $source, bool[] $options = []) @method static NodeList constArguments(Source|string $source, bool[] $options = []) @method static ArgumentNode argument(Source|string $source, bool[] $options = []) @method static ArgumentNode constArgument(Source|string $source, bool[] $options = []) @method static FragmentSpreadNode|InlineFragmentNode fragment(Source|string $source, bool[] $options = []) @method static FragmentDefinitionNode fragmentDefinition(Source|string $source, bool[] $options = []) @method static NameNode fragmentName(Source|string $source, bool[] $options = []) @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|NullValueNode|ObjectValueNode|StringValueNode|VariableNode valueLiteral(Source|string $source, bool[] $options = []) @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|NullValueNode|ObjectValueNode|StringValueNode constValueLiteral(Source|string $source, bool[] $options = []) @method static StringValueNode stringLiteral(Source|string $source, bool[] $options = []) @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|StringValueNode constValue(Source|string $source, bool[] $options = []) @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|ObjectValueNode|StringValueNode|VariableNode variableValue(Source|string $source, bool[] $options = []) @method static ListValueNode array(Source|string $source, bool[] $options = []) @method static ListValueNode constArray(Source|string $source, bool[] $options = []) @method static ObjectValueNode object(Source|string $source, bool[] $options = []) @method static ObjectValueNode constObject(Source|string $source, bool[] $options = []) @method static ObjectFieldNode objectField(Source|string $source, bool[] $options = []) @method static ObjectFieldNode constObjectField(Source|string $source, bool[] $options = []) @method static NodeList directives(Source|string $source, bool[] $options = []) @method static NodeList constDirectives(Source|string $source, bool[] $options = []) @method static DirectiveNode directive(Source|string $source, bool[] $options = []) @method static DirectiveNode constDirective(Source|string $source, bool[] $options = []) @method static ListTypeNode|NamedTypeNode|NonNullTypeNode typeReference(Source|string $source, bool[] $options = []) @method static NamedTypeNode namedType(Source|string $source, bool[] $options = []) @method static TypeSystemDefinitionNode typeSystemDefinition(Source|string $source, bool[] $options = []) @method static StringValueNode|null description(Source|string $source, bool[] $options = []) @method static SchemaDefinitionNode schemaDefinition(Source|string $source, bool[] $options = []) @method static OperationTypeDefinitionNode operationTypeDefinition(Source|string $source, bool[] $options = []) @method static ScalarTypeDefinitionNode scalarTypeDefinition(Source|string $source, bool[] $options = []) @method static ObjectTypeDefinitionNode objectTypeDefinition(Source|string $source, bool[] $options = []) @method static NodeList implementsInterfaces(Source|string $source, bool[] $options = []) @method static NodeList fieldsDefinition(Source|string $source, bool[] $options = []) @method static FieldDefinitionNode fieldDefinition(Source|string $source, bool[] $options = []) @method static NodeList argumentsDefinition(Source|string $source, bool[] $options = []) @method static InputValueDefinitionNode inputValueDefinition(Source|string $source, bool[] $options = []) @method static InterfaceTypeDefinitionNode interfaceTypeDefinition(Source|string $source, bool[] $options = []) @method static UnionTypeDefinitionNode unionTypeDefinition(Source|string $source, bool[] $options = []) @method static NodeList unionMemberTypes(Source|string $source, bool[] $options = []) @method static EnumTypeDefinitionNode enumTypeDefinition(Source|string $source, bool[] $options = []) @method static NodeList enumValuesDefinition(Source|string $source, bool[] $options = []) @method static EnumValueDefinitionNode enumValueDefinition(Source|string $source, bool[] $options = []) @method static InputObjectTypeDefinitionNode inputObjectTypeDefinition(Source|string $source, bool[] $options = []) @method static NodeList inputFieldsDefinition(Source|string $source, bool[] $options = []) @method static TypeExtensionNode typeExtension(Source|string $source, bool[] $options = []) @method static SchemaExtensionNode schemaTypeExtension(Source|string $source, bool[] $options = []) @method static ScalarTypeExtensionNode scalarTypeExtension(Source|string $source, bool[] $options = []) @method static ObjectTypeExtensionNode objectTypeExtension(Source|string $source, bool[] $options = []) @method static InterfaceTypeExtensionNode interfaceTypeExtension(Source|string $source, bool[] $options = []) @method static UnionTypeExtensionNode unionTypeExtension(Source|string $source, bool[] $options = []) @method static EnumTypeExtensionNode enumTypeExtension(Source|string $source, bool[] $options = []) @method static InputObjectTypeExtensionNode inputObjectTypeExtension(Source|string $source, bool[] $options = []) @method static DirectiveDefinitionNode directiveDefinition(Source|string $source, bool[] $options = []) @method static NodeList directiveLocations(Source|string $source, bool[] $options = []) @method static NameNode directiveLocation(Source|string $source, bool[] $options = []) GraphQL\\Language\\Parser Methods \u00b6 /** * Given a GraphQL source, parses it into a `GraphQL\\Language\\AST\\DocumentNode`. * * Throws `GraphQL\\Error\\SyntaxError` if a syntax error is encountered. * * @param Source|string $source * @phpstan-param ParserOptions $options * * @throws SyntaxError * * @api */ static function parse($source, array $options = []): GraphQL\\Language\\AST\\DocumentNode /** * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for that value. * * Throws `GraphQL\\Error\\SyntaxError` if a syntax error is encountered. * * This is useful within tools that operate upon GraphQL Values directly and * in isolation of complete GraphQL documents. * * Consider providing the results to the utility function: `GraphQL\\Utils\\AST::valueFromAST()`. * * @param Source|string $source * @phpstan-param ParserOptions $options * * @return BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|NullValueNode|ObjectValueNode|StringValueNode|VariableNode * * @api */ static function parseValue($source, array $options = []) /** * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for that type. * * Throws `GraphQL\\Error\\SyntaxError` if a syntax error is encountered. * * This is useful within tools that operate upon GraphQL Types directly and * in isolation of complete GraphQL documents. * * Consider providing the results to the utility function: `GraphQL\\Utils\\AST::typeFromAST()`. * * @param Source|string $source * @phpstan-param ParserOptions $options * * @return ListTypeNode|NamedTypeNode|NonNullTypeNode * * @api */ static function parseType($source, array $options = []) GraphQL\\Language\\Printer \u00b6 Prints AST to string. Capable of printing GraphQL queries and Type definition language. Useful for pretty-printing queries or printing back AST for logging, documentation, etc. Usage example: $query = 'query myQuery {someField}'; $ast = GraphQL\\Language\\Parser::parse($query); $printed = GraphQL\\Language\\Printer::doPrint($ast); GraphQL\\Language\\Printer Methods \u00b6 /** * Converts the AST of a GraphQL node to a string. * * Handles both executable definitions and schema definitions. * * @api */ static function doPrint(GraphQL\\Language\\AST\\Node $ast): string GraphQL\\Language\\Visitor \u00b6 Utility for efficient AST traversal and modification. visit() will walk through an AST using a depth first traversal, calling the visitor's enter function at each node in the traversal, and calling the leave function after visiting that node and all of its child nodes. By returning different values from the enter and leave functions, the behavior of the visitor can be altered, including skipping over a sub-tree of the AST (by returning false), editing the AST by returning a value or null to remove the value, or to stop the whole traversal by returning BREAK. When using visit() to edit an AST, the original AST will not be modified, and a new version of the AST with the changes applied will be returned from the visit function. $editedAST = Visitor::visit($ast, [ 'enter' => function ($node, $key, $parent, $path, $ancestors) { // return // null: no action // Visitor::skipNode(): skip visiting this node // Visitor::stop(): stop visiting altogether // Visitor::removeNode(): delete this node // any value: replace this node with the returned value }, 'leave' => function ($node, $key, $parent, $path, $ancestors) { // return // null: no action // Visitor::stop(): stop visiting altogether // Visitor::removeNode(): delete this node // any value: replace this node with the returned value } ]); Alternatively to providing enter() and leave() functions, a visitor can instead provide functions named the same as the kinds of AST nodes , or enter/leave visitors at a named key, leading to four permutations of visitor API: Named visitors triggered when entering a node a specific kind. Visitor::visit($ast, [ 'Kind' => function ($node) { // enter the \"Kind\" node } ]); Named visitors that trigger upon entering and leaving a node of a specific kind. Visitor::visit($ast, [ 'Kind' => [ 'enter' => function ($node) { // enter the \"Kind\" node } 'leave' => function ($node) { // leave the \"Kind\" node } ] ]); Generic visitors that trigger upon entering and leaving any node. Visitor::visit($ast, [ 'enter' => function ($node) { // enter any node }, 'leave' => function ($node) { // leave any node } ]); Parallel visitors for entering and leaving nodes of a specific kind. Visitor::visit($ast, [ 'enter' => [ 'Kind' => function($node) { // enter the \"Kind\" node } }, 'leave' => [ 'Kind' => function ($node) { // leave the \"Kind\" node } ] ]); @phpstan-type VisitorArray array |array > GraphQL\\Language\\Visitor Methods \u00b6 /** * Visit the AST (see class description for details). * * @template TNode of Node * * @param NodeList<TNode>|Node $root * @param VisitorArray $visitor * @param array<string, mixed>|null $keyMap * * @throws Exception * * @return Node|mixed * * @api */ static function visit(object $root, array $visitor, ?array $keyMap = null) /** * Returns marker for stopping. * * @api */ static function stop(): GraphQL\\Language\\VisitorStop /** * Returns marker for skipping the current node. * * @api */ static function skipNode(): GraphQL\\Language\\VisitorSkipNode /** * Returns marker for removing the current node. * * @api */ static function removeNode(): GraphQL\\Language\\VisitorRemoveNode GraphQL\\Language\\AST\\NodeKind \u00b6 Holds constants of possible AST nodes. GraphQL\\Language\\AST\\NodeKind Constants \u00b6 const NAME = 'Name'; const DOCUMENT = 'Document'; const OPERATION_DEFINITION = 'OperationDefinition'; const VARIABLE_DEFINITION = 'VariableDefinition'; const VARIABLE = 'Variable'; const SELECTION_SET = 'SelectionSet'; const FIELD = 'Field'; const ARGUMENT = 'Argument'; const FRAGMENT_SPREAD = 'FragmentSpread'; const INLINE_FRAGMENT = 'InlineFragment'; const FRAGMENT_DEFINITION = 'FragmentDefinition'; const INT = 'IntValue'; const FLOAT = 'FloatValue'; const STRING = 'StringValue'; const BOOLEAN = 'BooleanValue'; const ENUM = 'EnumValue'; const NULL = 'NullValue'; const LST = 'ListValue'; const OBJECT = 'ObjectValue'; const OBJECT_FIELD = 'ObjectField'; const DIRECTIVE = 'Directive'; const NAMED_TYPE = 'NamedType'; const LIST_TYPE = 'ListType'; const NON_NULL_TYPE = 'NonNullType'; const SCHEMA_DEFINITION = 'SchemaDefinition'; const OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition'; const SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition'; const OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition'; const FIELD_DEFINITION = 'FieldDefinition'; const INPUT_VALUE_DEFINITION = 'InputValueDefinition'; const INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition'; const UNION_TYPE_DEFINITION = 'UnionTypeDefinition'; const ENUM_TYPE_DEFINITION = 'EnumTypeDefinition'; const ENUM_VALUE_DEFINITION = 'EnumValueDefinition'; const INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition'; const SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension'; const OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension'; const INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension'; const UNION_TYPE_EXTENSION = 'UnionTypeExtension'; const ENUM_TYPE_EXTENSION = 'EnumTypeExtension'; const INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension'; const DIRECTIVE_DEFINITION = 'DirectiveDefinition'; const SCHEMA_EXTENSION = 'SchemaExtension'; const CLASS_MAP = [ 'Name' => 'GraphQL\\\\Language\\\\AST\\\\NameNode', 'Document' => 'GraphQL\\\\Language\\\\AST\\\\DocumentNode', 'OperationDefinition' => 'GraphQL\\\\Language\\\\AST\\\\OperationDefinitionNode', 'VariableDefinition' => 'GraphQL\\\\Language\\\\AST\\\\VariableDefinitionNode', 'Variable' => 'GraphQL\\\\Language\\\\AST\\\\VariableNode', 'SelectionSet' => 'GraphQL\\\\Language\\\\AST\\\\SelectionSetNode', 'Field' => 'GraphQL\\\\Language\\\\AST\\\\FieldNode', 'Argument' => 'GraphQL\\\\Language\\\\AST\\\\ArgumentNode', 'FragmentSpread' => 'GraphQL\\\\Language\\\\AST\\\\FragmentSpreadNode', 'InlineFragment' => 'GraphQL\\\\Language\\\\AST\\\\InlineFragmentNode', 'FragmentDefinition' => 'GraphQL\\\\Language\\\\AST\\\\FragmentDefinitionNode', 'IntValue' => 'GraphQL\\\\Language\\\\AST\\\\IntValueNode', 'FloatValue' => 'GraphQL\\\\Language\\\\AST\\\\FloatValueNode', 'StringValue' => 'GraphQL\\\\Language\\\\AST\\\\StringValueNode', 'BooleanValue' => 'GraphQL\\\\Language\\\\AST\\\\BooleanValueNode', 'EnumValue' => 'GraphQL\\\\Language\\\\AST\\\\EnumValueNode', 'NullValue' => 'GraphQL\\\\Language\\\\AST\\\\NullValueNode', 'ListValue' => 'GraphQL\\\\Language\\\\AST\\\\ListValueNode', 'ObjectValue' => 'GraphQL\\\\Language\\\\AST\\\\ObjectValueNode', 'ObjectField' => 'GraphQL\\\\Language\\\\AST\\\\ObjectFieldNode', 'Directive' => 'GraphQL\\\\Language\\\\AST\\\\DirectiveNode', 'NamedType' => 'GraphQL\\\\Language\\\\AST\\\\NamedTypeNode', 'ListType' => 'GraphQL\\\\Language\\\\AST\\\\ListTypeNode', 'NonNullType' => 'GraphQL\\\\Language\\\\AST\\\\NonNullTypeNode', 'SchemaDefinition' => 'GraphQL\\\\Language\\\\AST\\\\SchemaDefinitionNode', 'OperationTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\OperationTypeDefinitionNode', 'ScalarTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\ScalarTypeDefinitionNode', 'ObjectTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\ObjectTypeDefinitionNode', 'FieldDefinition' => 'GraphQL\\\\Language\\\\AST\\\\FieldDefinitionNode', 'InputValueDefinition' => 'GraphQL\\\\Language\\\\AST\\\\InputValueDefinitionNode', 'InterfaceTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\InterfaceTypeDefinitionNode', 'UnionTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\UnionTypeDefinitionNode', 'EnumTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\EnumTypeDefinitionNode', 'EnumValueDefinition' => 'GraphQL\\\\Language\\\\AST\\\\EnumValueDefinitionNode', 'InputObjectTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\InputObjectTypeDefinitionNode', 'ScalarTypeExtension' => 'GraphQL\\\\Language\\\\AST\\\\ScalarTypeExtensionNode', 'ObjectTypeExtension' => 'GraphQL\\\\Language\\\\AST\\\\ObjectTypeExtensionNode', 'InterfaceTypeExtension' => 'GraphQL\\\\Language\\\\AST\\\\InterfaceTypeExtensionNode', 'UnionTypeExtension' => 'GraphQL\\\\Language\\\\AST\\\\UnionTypeExtensionNode', 'EnumTypeExtension' => 'GraphQL\\\\Language\\\\AST\\\\EnumTypeExtensionNode', 'InputObjectTypeExtension' => 'GraphQL\\\\Language\\\\AST\\\\InputObjectTypeExtensionNode', 'DirectiveDefinition' => 'GraphQL\\\\Language\\\\AST\\\\DirectiveDefinitionNode', ]; GraphQL\\Executor\\Executor \u00b6 Implements the \"Evaluating requests\" section of the GraphQL specification. @phpstan-type FieldResolver callable(mixed, array , mixed, ResolveInfo): mixed @see https://github.com/vimeo/psalm/issues/6928 @psalm-type FieldResolver callable(mixed, array, mixed, ResolveInfo): mixed @phpstan-type ImplementationFactory callable(PromiseAdapter, Schema, DocumentNode, mixed, mixed, array , ?string, callable): ExecutorImplementation @see https://github.com/vimeo/psalm/issues/6928, https://github.com/vimeo/psalm/issues/7527 @psalm-type ImplementationFactory callable(PromiseAdapter, Schema, DocumentNode, mixed, mixed, array, ?string, callable): ExecutorImplementation GraphQL\\Executor\\Executor Methods \u00b6 /** * Executes DocumentNode against given $schema. * * Always returns ExecutionResult and never throws. * All errors which occur during operation execution are collected in `$result->errors`. * * @param mixed $rootValue * @param mixed $contextValue * @param array<string, mixed>|null $variableValues * @phpstan-param FieldResolver|null $fieldResolver * * @api */ static function execute( GraphQL\\Type\\Schema $schema, GraphQL\\Language\\AST\\DocumentNode $documentNode, $rootValue = null, $contextValue = null, ?array $variableValues = null, ?string $operationName = null, ?callable $fieldResolver = null ): GraphQL\\Executor\\ExecutionResult /** * Same as execute(), but requires promise adapter and returns a promise which is always * fulfilled with an instance of ExecutionResult and never rejected. * * Useful for async PHP platforms. * * @param mixed $rootValue * @param mixed $contextValue * @param array<string, mixed>|null $variableValues * @phpstan-param FieldResolver|null $fieldResolver * * @api */ static function promiseToExecute( GraphQL\\Executor\\Promise\\PromiseAdapter $promiseAdapter, GraphQL\\Type\\Schema $schema, GraphQL\\Language\\AST\\DocumentNode $documentNode, $rootValue = null, $contextValue = null, ?array $variableValues = null, ?string $operationName = null, ?callable $fieldResolver = null ): GraphQL\\Executor\\Promise\\Promise GraphQL\\Executor\\ExecutionResult \u00b6 Returned after query execution . Represents both - result of successful execution and of a failed one (with errors collected in errors prop). Could be converted to spec-compliant serializable array using toArray() . @see Throwable @phpstan-type SerializableError array{ message: string, locations?: array , path?: array , extensions?: array } @phpstan-type SerializableErrors array @phpstan-type SerializableResult array{ data?: array , errors?: SerializableErrors, extensions?: array } @phpstan-type ErrorFormatter callable(Throwable): SerializableError @phpstan-type ErrorsHandler callable(array $errors, ErrorFormatter $formatter): SerializableErrors @see https://github.com/vimeo/psalm/issues/6928 @psalm-type ErrorsHandler callable(Error[], ErrorFormatter): SerializableErrors GraphQL\\Executor\\ExecutionResult Props \u00b6 /** * Data collected from resolvers during query execution. * * @api * * @var array<string, mixed>|null */ public $data; /** * Errors registered during query execution. * * If an error was caused by exception thrown in resolver, $error->getPrevious() would * contain original exception. * * @api * * @var array<Error> */ public $errors; /** * User-defined serializable array of extensions included in serialized result. * * @api * * @var array<string, mixed>|null */ public $extensions; GraphQL\\Executor\\ExecutionResult Methods \u00b6 /** * Define custom error formatting (must conform to http://facebook.github.io/graphql/#sec-Errors). * * Expected signature is: function (GraphQL\\Error\\Error $error): array * * Default formatter is \"GraphQL\\Error\\FormattedError::createFromException\" * * Expected returned value must be an array: * array( * 'message' => 'errorMessage', * // ... other keys * ); * * @phpstan-param ErrorFormatter|null $errorFormatter * * @api */ function setErrorFormatter(?callable $errorFormatter): self /** * Define custom logic for error handling (filtering, logging, etc). * * Expected handler signature is: * fn (array $errors, callable $formatter): array * * Default handler is: * fn (array $errors, callable $formatter): array => array_map($formatter, $errors) * * @phpstan-param ErrorsHandler|null $errorsHandler * * @api */ function setErrorsHandler(?callable $errorsHandler): self /** * Converts GraphQL query result to spec-compliant serializable array using provided * errors handler and formatter. * * If debug argument is passed, output of error formatter is enriched which debugging information * (\"debugMessage\", \"trace\" keys depending on flags). * * $debug argument must sum of flags from @see \\GraphQL\\Error\\DebugFlag * * @phpstan-return SerializableResult * * @api */ function toArray(int $debug = 'GraphQL\\\\Error\\\\DebugFlag::NONE'): array GraphQL\\Executor\\Promise\\PromiseAdapter \u00b6 Provides a means for integration of async PHP platforms ( related docs ). GraphQL\\Executor\\Promise\\PromiseAdapter Methods \u00b6 /** * Is the value a promise or a deferred of the underlying platform? * * @param mixed $value * * @api */ function isThenable($value): bool /** * Converts thenable of the underlying platform into GraphQL\\Executor\\Promise\\Promise instance. * * @param mixed $thenable * * @api */ function convertThenable($thenable): GraphQL\\Executor\\Promise\\Promise /** * Accepts our Promise wrapper, extracts adopted promise out of it and executes actual `then` logic described * in Promises/A+ specs. Then returns new wrapped instance of GraphQL\\Executor\\Promise\\Promise. * * @api */ function then( GraphQL\\Executor\\Promise\\Promise $promise, ?callable $onFulfilled = null, ?callable $onRejected = null ): GraphQL\\Executor\\Promise\\Promise /** * Creates a Promise from the given resolver callable. * * @param callable(callable $resolve, callable $reject): void $resolver * * @api */ function create(callable $resolver): GraphQL\\Executor\\Promise\\Promise /** * Creates a fulfilled Promise for a value if the value is not a promise. * * @param mixed $value * * @api */ function createFulfilled($value = null): GraphQL\\Executor\\Promise\\Promise /** * Creates a rejected promise for a reason if the reason is not a promise. * * If the provided reason is a promise, then it is returned as-is. * * @api */ function createRejected(Throwable $reason): GraphQL\\Executor\\Promise\\Promise /** * Given an iterable of promises (or values), returns a promise that is fulfilled when all the * items in the iterable are fulfilled. * * @param iterable<Promise|mixed> $promisesOrValues * * @api */ function all(iterable $promisesOrValues): GraphQL\\Executor\\Promise\\Promise GraphQL\\Validator\\DocumentValidator \u00b6 Implements the \"Validation\" section of the spec. Validation runs synchronously, returning an array of encountered errors, or an empty array if no errors were encountered and the document is valid. A list of specific validation rules may be provided. If not provided, the default list of rules defined by the GraphQL specification will be used. Each validation rule is an instance of GraphQL\\Validator\\Rules\\ValidationRule which returns a visitor (see the GraphQL\\Language\\Visitor API ). Visitor methods are expected to return an instance of GraphQL\\Error\\Error , or array of such instances when invalid. Optionally a custom TypeInfo instance may be provided. If not provided, one will be created from the provided schema. GraphQL\\Validator\\DocumentValidator Methods \u00b6 /** * Validate a GraphQL query against a schema. * * @param array<ValidationRule>|null $rules * * @return array<int, Error> * * @api */ static function validate( GraphQL\\Type\\Schema $schema, GraphQL\\Language\\AST\\DocumentNode $ast, ?array $rules = null, ?GraphQL\\Utils\\TypeInfo $typeInfo = null ): array /** * Returns all global validation rules. * * @return array<string, ValidationRule> * * @api */ static function allRules(): array /** * Returns global validation rule by name. * * Standard rules are named by class name, so example usage for such rules: * * @example DocumentValidator::getRule(GraphQL\\Validator\\Rules\\QueryComplexity::class); * * @api */ static function getRule(string $name): ?GraphQL\\Validator\\Rules\\ValidationRule /** * Add rule to list of global validation rules. * * @api */ static function addRule(GraphQL\\Validator\\Rules\\ValidationRule $rule): void /** * Remove rule from list of global validation rules. * * @api */ static function removeRule(GraphQL\\Validator\\Rules\\ValidationRule $rule): void GraphQL\\Error\\Error \u00b6 Describes an Error found during the parse, validate, or execute phases of performing a GraphQL operation. In addition to a message and stack trace, it also includes information about the locations in a GraphQL document and/or execution result that correspond to the Error. When the error was caused by an exception thrown in resolver, original exception is available via getPrevious() . Also read related docs on error handling Class extends standard PHP \\Exception , so all standard methods of base \\Exception class are available in addition to those listed below. GraphQL\\Error\\Error Methods \u00b6 /** * An array of locations within the source GraphQL document which correspond to this error. * * Each entry has information about `line` and `column` within source GraphQL document: * $location->line; * $location->column; * * Errors during validation often contain multiple locations, for example to * point out to field mentioned in multiple fragments. Errors during execution include a * single location, the field which produced the error. * * @return array<int, SourceLocation> * * @api */ function getLocations(): array /** * Returns an array describing the path from the root value to the field which produced this error. * Only included for execution errors. * * @return array<int, int|string>|null * * @api */ function getPath(): ?array GraphQL\\Error\\Warning \u00b6 Encapsulates warnings produced by the library. Warnings can be suppressed (individually or all) if required. Also, it is possible to override warning handler (which is trigger_error() by default). @phpstan-type WarningHandler callable(string $errorMessage, int $warningId, ?int $messageLevel): void @see https://github.com/vimeo/psalm/issues/7527 @psalm-type WarningHandler callable(string, int, int|null): void GraphQL\\Error\\Warning Constants \u00b6 const NONE = 0; const WARNING_ASSIGN = 2; const WARNING_CONFIG = 4; const WARNING_FULL_SCHEMA_SCAN = 8; const WARNING_CONFIG_DEPRECATION = 16; const WARNING_NOT_A_TYPE = 32; const ALL = 63; GraphQL\\Error\\Warning Methods \u00b6 /** * Sets warning handler which can intercept all system warnings. * When not set, trigger_error() is used to notify about warnings. * * @phpstan-param WarningHandler|null $warningHandler * * @api */ static function setWarningHandler(?callable $warningHandler = null): void /** * Suppress warning by id (has no effect when custom warning handler is set). * * @param bool|int $suppress * * @example Warning::suppress(Warning::WARNING_NOT_A_TYPE) suppress a specific warning * @example Warning::suppress(true) suppresses all warnings * @example Warning::suppress(false) enables all warnings * * @api */ static function suppress($suppress = true): void /** * Re-enable previously suppressed warning by id (has no effect when custom warning handler is set). * * @param bool|int $enable * * @example Warning::suppress(Warning::WARNING_NOT_A_TYPE) re-enables a specific warning * @example Warning::suppress(true) re-enables all warnings * @example Warning::suppress(false) suppresses all warnings * * @api */ static function enable($enable = true): void GraphQL\\Error\\ClientAware \u00b6 Implementing ClientAware allows graphql-php to decide if this error is safe to be shown to clients. Only errors that both implement this interface and return true from isClientSafe() will retain their original error message during formatting. All other errors will have their message replaced with \"Internal server error\". GraphQL\\Error\\ClientAware Methods \u00b6 /** * Is it safe to show the error message to clients? * * @api */ function isClientSafe(): bool GraphQL\\Error\\DebugFlag \u00b6 Collection of flags for error debugging . GraphQL\\Error\\DebugFlag Constants \u00b6 const NONE = 0; const INCLUDE_DEBUG_MESSAGE = 1; const INCLUDE_TRACE = 2; const RETHROW_INTERNAL_EXCEPTIONS = 4; const RETHROW_UNSAFE_EXCEPTIONS = 8; GraphQL\\Error\\FormattedError \u00b6 This class is used for default error formatting . It converts PHP exceptions to spec-compliant errors and provides tools for error debugging. @see ExecutionResult @phpstan-import-type SerializableError from ExecutionResult @phpstan-import-type ErrorFormatter from ExecutionResult GraphQL\\Error\\FormattedError Methods \u00b6 /** * Set default error message for internal errors formatted using createFormattedError(). * This value can be overridden by passing 3rd argument to `createFormattedError()`. * * @api */ static function setInternalErrorMessage(string $msg): void /** * Convert any exception to a GraphQL spec compliant array. * * This method only exposes the exception message when the given exception * implements the ClientAware interface, or when debug flags are passed. * * For a list of available debug flags @see \\GraphQL\\Error\\DebugFlag constants. * * @return SerializableError * * @api */ static function createFromException( Throwable $exception, int $debugFlag = 'GraphQL\\\\Error\\\\DebugFlag::NONE', ?string $internalErrorMessage = null ): array /** * Returns error trace as serializable array. * * @return array<int, array{ * file?: string, * line?: int, * function?: string, * call?: string, * }> * * @api */ static function toSafeTrace(Throwable $error): array GraphQL\\Server\\StandardServer \u00b6 GraphQL server compatible with both: express-graphql and Apollo Server . Usage Example:. $server = new StandardServer([ 'schema' => $mySchema ]); $server->handleRequest(); Or using ServerConfig instance: $config = GraphQL\\Server\\ServerConfig::create() ->setSchema($mySchema) ->setContext($myContext); $server = new GraphQL\\Server\\StandardServer($config); $server->handleRequest(); See dedicated section in docs for details. GraphQL\\Server\\StandardServer Methods \u00b6 /** * Converts and exception to error and sends spec-compliant HTTP 500 error. * Useful when an exception is thrown somewhere outside of server execution context * (e.g. during schema instantiation). * * @api */ static function send500Error(Throwable $error, int $debug = 'GraphQL\\\\Error\\\\DebugFlag::NONE'): void /** * Creates new instance of a standard GraphQL HTTP server. * * @param ServerConfig|array<string, mixed> $config * * @api */ function __construct($config) /** * Parses HTTP request, executes and emits response (using standard PHP `header` function and `echo`). * * By default (when $parsedBody is not set) it uses PHP globals to parse a request. * It is possible to implement request parsing elsewhere (e.g. using framework Request instance) * and then pass it to the server. * * See `executeRequest()` if you prefer to emit response yourself * (e.g. using Response object of some framework) * * @param OperationParams|array<OperationParams> $parsedBody * * @api */ function handleRequest($parsedBody = null): void /** * Executes GraphQL operation and returns execution result * (or promise when promise adapter is different from SyncPromiseAdapter). * * By default (when $parsedBody is not set) it uses PHP globals to parse a request. * It is possible to implement request parsing elsewhere (e.g. using framework Request instance) * and then pass it to the server. * * PSR-7 compatible method executePsrRequest() does exactly this. * * @param OperationParams|array<OperationParams> $parsedBody * * @throws InvariantViolation * * @return ExecutionResult|array<int, ExecutionResult>|Promise * * @api */ function executeRequest($parsedBody = null) /** * Executes PSR-7 request and fulfills PSR-7 response. * * See `executePsrRequest()` if you prefer to create response yourself * (e.g. using specific JsonResponse instance of some framework). * * @return ResponseInterface|Promise * * @api */ function processPsrRequest( Psr\\Http\\Message\\RequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response, Psr\\Http\\Message\\StreamInterface $writableBodyStream ) /** * Executes GraphQL operation and returns execution result * (or promise when promise adapter is different from SyncPromiseAdapter). * * @return ExecutionResult|array<int, ExecutionResult>|Promise * * @api */ function executePsrRequest(Psr\\Http\\Message\\RequestInterface $request) /** * Returns an instance of Server helper, which contains most of the actual logic for * parsing / validating / executing request (which could be re-used by other server implementations). * * @api */ function getHelper(): GraphQL\\Server\\Helper GraphQL\\Server\\ServerConfig \u00b6 Server configuration class. Could be passed directly to server constructor. List of options accepted by create method is described in docs . Usage example: $config = GraphQL\\Server\\ServerConfig::create() ->setSchema($mySchema) ->setContext($myContext); $server = new GraphQL\\Server\\StandardServer($config); @see ExecutionResult @phpstan-type PersistedQueryLoader callable(string $queryId, OperationParams $operation): (string|DocumentNode) @phpstan-type RootValueResolver callable(OperationParams $operation, DocumentNode $doc, string $operationType): mixed @phpstan-type ValidationRulesOption array |null|callable(OperationParams $operation, DocumentNode $doc, string $operationType): array @phpstan-import-type ErrorsHandler from ExecutionResult @phpstan-import-type ErrorFormatter from ExecutionResult GraphQL\\Server\\ServerConfig Methods \u00b6 /** * Converts an array of options to instance of ServerConfig * (or just returns empty config when array is not passed). * * @param array<string, mixed> $config * * @api */ static function create(array $config = []): self /** * @api */ function setSchema(GraphQL\\Type\\Schema $schema): self /** * @param mixed|callable $context * * @api */ function setContext($context): self /** * @param mixed|callable $rootValue * @phpstan-param mixed|RootValueResolver $rootValue * * @api */ function setRootValue($rootValue): self /** * @phpstan-param ErrorFormatter $errorFormatter * * @api */ function setErrorFormatter(callable $errorFormatter): self /** * @phpstan-param ErrorsHandler $handler * * @api */ function setErrorsHandler(callable $handler): self /** * Set validation rules for this server. * * @param array<ValidationRule>|callable|null $validationRules * @phpstan-param ValidationRulesOption $validationRules * * @api */ function setValidationRules($validationRules): self /** * @api */ function setFieldResolver(callable $fieldResolver): self /** * @phpstan-param PersistedQueryLoader|null $persistedQueryLoader * * @api */ function setPersistedQueryLoader(?callable $persistedQueryLoader): self /** * Set response debug flags. * * @see \\GraphQL\\Error\\DebugFlag class for a list of all available flags * * @api */ function setDebugFlag(int $debugFlag = 'GraphQL\\\\Error\\\\DebugFlag::INCLUDE_DEBUG_MESSAGE'): self /** * Allow batching queries (disabled by default). * * @api */ function setQueryBatching(bool $enableBatching): self /** * @api */ function setPromiseAdapter(GraphQL\\Executor\\Promise\\PromiseAdapter $promiseAdapter): self GraphQL\\Server\\Helper \u00b6 Contains functionality that could be re-used by various server implementations. GraphQL\\Server\\Helper Methods \u00b6 /** * Parses HTTP request using PHP globals and returns GraphQL OperationParams * contained in this request. For batched requests it returns an array of OperationParams. * * This function does not check validity of these params * (validation is performed separately in validateOperationParams() method). * * If $readRawBodyFn argument is not provided - will attempt to read raw request body * from `php://input` stream. * * Internally it normalizes input to $method, $bodyParams and $queryParams and * calls `parseRequestParams()` to produce actual return value. * * For PSR-7 request parsing use `parsePsrRequest()` instead. * * @throws RequestError * * @return OperationParams|array<int, OperationParams> * * @api */ function parseHttpRequest(?callable $readRawBodyFn = null) /** * Parses normalized request params and returns instance of OperationParams * or array of OperationParams in case of batch operation. * * Returned value is a suitable input for `executeOperation` or `executeBatch` (if array) * * @param array<mixed> $bodyParams * @param array<mixed> $queryParams * * @throws RequestError * * @return OperationParams|array<int, OperationParams> * * @api */ function parseRequestParams(string $method, array $bodyParams, array $queryParams) /** * Checks validity of OperationParams extracted from HTTP request and returns an array of errors * if params are invalid (or empty array when params are valid). * * @return array<int, RequestError> * * @api */ function validateOperationParams(GraphQL\\Server\\OperationParams $params): array /** * Executes GraphQL operation with given server configuration and returns execution result * (or promise when promise adapter is different from SyncPromiseAdapter). * * @return ExecutionResult|Promise * * @api */ function executeOperation(GraphQL\\Server\\ServerConfig $config, GraphQL\\Server\\OperationParams $op) /** * Executes batched GraphQL operations with shared promise queue * (thus, effectively batching deferreds|promises of all queries at once). * * @param array<OperationParams> $operations * * @return array<int, ExecutionResult>|Promise * * @api */ function executeBatch(GraphQL\\Server\\ServerConfig $config, array $operations) /** * Send response using standard PHP `header()` and `echo`. * * @param Promise|ExecutionResult|array<ExecutionResult> $result * * @api */ function sendResponse($result): void /** * Converts PSR-7 request to OperationParams or an array thereof. * * @throws RequestError * * @return OperationParams|array<OperationParams> * * @api */ function parsePsrRequest(Psr\\Http\\Message\\RequestInterface $request) /** * Converts query execution result to PSR-7 response. * * @param Promise|ExecutionResult|array<ExecutionResult> $result * * @return Promise|ResponseInterface * * @api */ function toPsrResponse( $result, Psr\\Http\\Message\\ResponseInterface $response, Psr\\Http\\Message\\StreamInterface $writableBodyStream ) GraphQL\\Server\\OperationParams \u00b6 Structure representing parsed HTTP parameters for GraphQL operation. The properties in this class are not strictly typed, as this class is only meant to serve as an intermediary representation which is not yet validated. GraphQL\\Server\\OperationParams Props \u00b6 /** * Id of the query (when using persisted queries). * * Valid aliases (case-insensitive): * - id * - queryId * - documentId * * @api * * @var mixed should be string|null */ public $queryId; /** * A document containing GraphQL operations and fragments to execute. * * @api * * @var mixed should be string|null */ public $query; /** * The name of the operation in the document to execute. * * @api * * @var mixed should be string|null */ public $operation; /** * Values for any variables defined by the operation. * * @api * * @var mixed should be array<string, mixed> */ public $variables; /** * Reserved for implementors to extend the protocol however they see fit. * * @api * * @var mixed should be array<string, mixed> */ public $extensions; /** * Executed in read-only context (e.g. via HTTP GET request)? * * @api */ public $readOnly; /** * The raw params used to construct this instance. * * @api * * @var array<string, mixed> */ public $originalInput; GraphQL\\Server\\OperationParams Methods \u00b6 /** * Creates an instance from given array. * * @param array<string, mixed> $params * * @api */ static function create(array $params, bool $readonly = false): GraphQL\\Server\\OperationParams GraphQL\\Utils\\BuildSchema \u00b6 Build instance of @see \\GraphQL\\Type\\Schema out of schema language definition (string or parsed AST). See schema definition language docs for details. @phpstan-import-type TypeConfigDecorator from ASTDefinitionBuilder @phpstan-type BuildSchemaOptions array{ assumeValid?: bool, assumeValidSDL?: bool } assumeValid: When building a schema from a GraphQL service's introspection result, it might be safe to assume the schema is valid. Set to true to assume the produced schema is valid. Default: false assumeValidSDL: Set to true to assume the SDL is valid. Default: false GraphQL\\Utils\\BuildSchema Methods \u00b6 /** * A helper function to build a GraphQLSchema directly from a source * document. * * @param DocumentNode|Source|string $source * @phpstan-param TypeConfigDecorator|null $typeConfigDecorator * * @param array<string, bool> $options * @phpstan-param BuildSchemaOptions $options * * @api */ static function build($source, ?callable $typeConfigDecorator = null, array $options = []): GraphQL\\Type\\Schema /** * This takes the AST of a schema from @see \\GraphQL\\Language\\Parser::parse(). * * If no schema definition is provided, then it will look for types named Query and Mutation. * * Given that AST it constructs a @see \\GraphQL\\Type\\Schema. The resulting schema * has no resolve methods, so execution will use default resolvers. * * @phpstan-param TypeConfigDecorator|null $typeConfigDecorator * * @param array<string, bool> $options * @phpstan-param BuildSchemaOptions $options * * @throws Error * * @api */ static function buildAST( GraphQL\\Language\\AST\\DocumentNode $ast, ?callable $typeConfigDecorator = null, array $options = [] ): GraphQL\\Type\\Schema GraphQL\\Utils\\AST \u00b6 Various utilities dealing with AST. GraphQL\\Utils\\AST Methods \u00b6 /** * Convert representation of AST as an associative array to instance of GraphQL\\Language\\AST\\Node. * * For example: * * ```php * AST::fromArray([ * 'kind' => 'ListValue', * 'values' => [ * ['kind' => 'StringValue', 'value' => 'my str'], * ['kind' => 'StringValue', 'value' => 'my other str'] * ], * 'loc' => ['start' => 21, 'end' => 25] * ]); * ``` * * Will produce instance of `ListValueNode` where `values` prop is a lazily-evaluated `NodeList` * returning instances of `StringValueNode` on access. * * This is a reverse operation for AST::toArray($node) * * @param array<string, mixed> $node * * @api */ static function fromArray(array $node): GraphQL\\Language\\AST\\Node /** * Convert AST node to serializable array. * * @return array<string, mixed> * * @api */ static function toArray(GraphQL\\Language\\AST\\Node $node): array /** * Produces a GraphQL Value AST given a PHP value. * * Optionally, a GraphQL type may be provided, which will be used to * disambiguate between value primitives. * * | PHP Value | GraphQL Value | * | ------------- | -------------------- | * | Object | Input Object | * | Assoc Array | Input Object | * | Array | List | * | Boolean | Boolean | * | String | String / Enum Value | * | Int | Int | * | Float | Int / Float | * | Mixed | Enum Value | * | null | NullValue | * * @param mixed $value * @param InputType&Type $type * * @return (ValueNode&Node)|null * * @api */ static function astFromValue($value, GraphQL\\Type\\Definition\\InputType $type): ?GraphQL\\Language\\AST\\ValueNode /** * Produces a PHP value given a GraphQL Value AST. * * A GraphQL type must be provided, which will be used to interpret different * GraphQL Value literals. * * Returns `null` when the value could not be validly coerced according to * the provided type. * * | GraphQL Value | PHP Value | * | -------------------- | ------------- | * | Input Object | Assoc Array | * | List | Array | * | Boolean | Boolean | * | String | String | * | Int / Float | Int / Float | * | Enum Value | Mixed | * | Null Value | null | * * @param (ValueNode&Node)|null $valueNode * @param array<string, mixed>|null $variables * * @throws Exception * * @return mixed * * @api */ static function valueFromAST( ?GraphQL\\Language\\AST\\ValueNode $valueNode, GraphQL\\Type\\Definition\\Type $type, ?array $variables = null ) /** * Produces a PHP value given a GraphQL Value AST. * * Unlike `valueFromAST()`, no type is provided. The resulting PHP value * will reflect the provided GraphQL value AST. * * | GraphQL Value | PHP Value | * | -------------------- | ------------- | * | Input Object | Assoc Array | * | List | Array | * | Boolean | Boolean | * | String | String | * | Int / Float | Int / Float | * | Enum | Mixed | * | Null | null | * * @param array<string, mixed>|null $variables * * @throws Exception * * @return mixed * * @api */ static function valueFromASTUntyped(GraphQL\\Language\\AST\\Node $valueNode, ?array $variables = null) /** * Returns type definition for given AST Type node. * * @param callable(string): ?Type $typeLoader * @param NamedTypeNode|ListTypeNode|NonNullTypeNode $inputTypeNode * * @throws Exception * * @api */ static function typeFromAST(callable $typeLoader, GraphQL\\Language\\AST\\Node $inputTypeNode): ?GraphQL\\Type\\Definition\\Type /** * Returns the operation within a document by name. * * If a name is not provided, an operation is only returned if the document has exactly one. * * @api */ static function getOperationAST(GraphQL\\Language\\AST\\DocumentNode $document, ?string $operationName = null): ?GraphQL\\Language\\AST\\OperationDefinitionNode /** * Provided a collection of ASTs, presumably each from different files, * concatenate the ASTs together into batched AST, useful for validating many * GraphQL source files which together represent one conceptual application. * * @param array<DocumentNode> $documents * * @api */ static function concatAST(array $documents): GraphQL\\Language\\AST\\DocumentNode GraphQL\\Utils\\SchemaPrinter \u00b6 Prints the contents of a Schema in schema definition language. @phpstan-type Options array{sortTypes?: bool} GraphQL\\Utils\\SchemaPrinter Methods \u00b6 /** * @param array<string, bool> $options * @phpstan-param Options $options * * @api */ static function doPrint(GraphQL\\Type\\Schema $schema, array $options = []): string /** * @param array<string, bool> $options * @phpstan-param Options $options * * @api */ static function printIntrospectionSchema(GraphQL\\Type\\Schema $schema, array $options = []): string","title":"Class Reference"},{"location":"class-reference/#graphqlgraphql","text":"This is the primary facade for fulfilling GraphQL operations. See related documentation . @phpstan-import-type FieldResolver from Executor","title":"GraphQL\\GraphQL"},{"location":"class-reference/#graphqlgraphql-methods","text":"/** * Executes graphql query. * * More sophisticated GraphQL servers, such as those which persist queries, * may wish to separate the validation and execution phases to a static time * tooling step, and a server runtime step. * * Available options: * * schema: * The GraphQL type system to use when validating and executing a query. * source: * A GraphQL language formatted string representing the requested operation. * rootValue: * The value provided as the first argument to resolver functions on the top * level type (e.g. the query object type). * contextValue: * The context value is provided as an argument to resolver functions after * field arguments. It is used to pass shared information useful at any point * during executing this query, for example the currently logged in user and * connections to databases or other services. * variableValues: * A mapping of variable name to runtime value to use for all variables * defined in the requestString. * operationName: * The name of the operation to use if requestString contains multiple * possible operations. Can be omitted if requestString contains only * one operation. * fieldResolver: * A resolver function to use when one is not provided by the schema. * If not provided, the default field resolver is used (which looks for a * value on the source value with the field's name). * validationRules: * A set of rules for query validation step. Default value is all available rules. * Empty array would allow to skip query validation (may be convenient for persisted * queries which are validated before persisting and assumed valid during execution) * * @param string|DocumentNode $source * @param mixed $rootValue * @param mixed $contextValue * @param array<string, mixed>|null $variableValues * @param array<ValidationRule>|null $validationRules * * @api */ static function executeQuery( GraphQL\\Type\\Schema $schema, $source, $rootValue = null, $contextValue = null, ?array $variableValues = null, ?string $operationName = null, ?callable $fieldResolver = null, ?array $validationRules = null ): GraphQL\\Executor\\ExecutionResult /** * Same as executeQuery(), but requires PromiseAdapter and always returns a Promise. * Useful for Async PHP platforms. * * @param string|DocumentNode $source * @param mixed $rootValue * @param mixed $context * @param array<string, mixed>|null $variableValues * @param array<ValidationRule>|null $validationRules * * @api */ static function promiseToExecute( GraphQL\\Executor\\Promise\\PromiseAdapter $promiseAdapter, GraphQL\\Type\\Schema $schema, $source, $rootValue = null, $context = null, ?array $variableValues = null, ?string $operationName = null, ?callable $fieldResolver = null, ?array $validationRules = null ): GraphQL\\Executor\\Promise\\Promise /** * Returns directives defined in GraphQL spec. * * @return array<string, Directive> * * @api */ static function getStandardDirectives(): array /** * Returns types defined in GraphQL spec. * * @return array<string, ScalarType> * * @api */ static function getStandardTypes(): array /** * Replaces standard types with types from this list (matching by name). * * Standard types not listed here remain untouched. * * @param array<string, ScalarType> $types * * @api */ static function overrideStandardTypes(array $types): void /** * Returns standard validation rules implementing GraphQL spec. * * @return array<class-string<ValidationRule>, ValidationRule> * * @api */ static function getStandardValidationRules(): array /** * Set default resolver implementation. * * @phpstan-param FieldResolver $fn * * @api */ static function setDefaultFieldResolver(callable $fn): void","title":"GraphQL\\GraphQL Methods"},{"location":"class-reference/#graphqltypedefinitiontype","text":"Registry of standard GraphQL types and base class for all other types.","title":"GraphQL\\Type\\Definition\\Type"},{"location":"class-reference/#graphqltypedefinitiontype-methods","text":"/** * @api */ static function id(): GraphQL\\Type\\Definition\\ScalarType /** * @api */ static function string(): GraphQL\\Type\\Definition\\ScalarType /** * @api */ static function boolean(): GraphQL\\Type\\Definition\\ScalarType /** * @api */ static function int(): GraphQL\\Type\\Definition\\ScalarType /** * @api */ static function float(): GraphQL\\Type\\Definition\\ScalarType /** * @template T of Type * * @param T|callable():T $type * * @return ListOfType<T> * * @api */ static function listOf($type): GraphQL\\Type\\Definition\\ListOfType /** * @param (NullableType&Type)|callable():(NullableType&Type) $type * * @api */ static function nonNull($type): GraphQL\\Type\\Definition\\NonNull /** * @param mixed $type * * @api */ static function isInputType($type): bool /** * @return (Type&NamedType)|null * * @api */ static function getNamedType(?GraphQL\\Type\\Definition\\Type $type): ?GraphQL\\Type\\Definition\\Type /** * @param mixed $type * * @api */ static function isOutputType($type): bool /** * @param mixed $type * * @api */ static function isLeafType($type): bool /** * @param mixed $type * * @api */ static function isCompositeType($type): bool /** * @param mixed $type * * @api */ static function isAbstractType($type): bool /** * @return Type&NullableType * * @api */ static function getNullableType(GraphQL\\Type\\Definition\\Type $type): GraphQL\\Type\\Definition\\Type","title":"GraphQL\\Type\\Definition\\Type Methods"},{"location":"class-reference/#graphqltypedefinitionresolveinfo","text":"Structure containing information useful for field resolution process. Passed as 4th argument to every field resolver. See docs on field resolving (data fetching) . @phpstan-import-type QueryPlanOptions from QueryPlan @phpstan-type Path array","title":"GraphQL\\Type\\Definition\\ResolveInfo"},{"location":"class-reference/#graphqltypedefinitionresolveinfo-props","text":"/** * The definition of the field being resolved. * * @api */ public $fieldDefinition; /** * The name of the field being resolved. * * @api */ public $fieldName; /** * Expected return type of the field being resolved. * * @api */ public $returnType; /** * AST of all nodes referencing this field in the query. * * @api * * @var ArrayObject<int, FieldNode> */ public $fieldNodes; /** * Parent type of the field being resolved. * * @api */ public $parentType; /** * Path to this field from the very root value. * * @api * * @var array<int, string|int> * @phpstan-var Path */ public $path; /** * Instance of a schema used for execution. * * @api */ public $schema; /** * AST of all fragments defined in query. * * @api * * @var array<string, FragmentDefinitionNode> */ public $fragments; /** * Root value passed to query execution. * * @api * * @var mixed */ public $rootValue; /** * AST of operation definition node (query, mutation). * * @api */ public $operation; /** * Array of variables passed to query execution. * * @api * * @var array<string, mixed> */ public $variableValues;","title":"GraphQL\\Type\\Definition\\ResolveInfo Props"},{"location":"class-reference/#graphqltypedefinitionresolveinfo-methods","text":"/** * Helper method that returns names of all fields selected in query for * $this->fieldName up to $depth levels. * * Example: * query MyQuery{ * { * root { * id, * nested { * nested1 * nested2 { * nested3 * } * } * } * } * * Given this ResolveInfo instance is a part of \"root\" field resolution, and $depth === 1, * method will return: * [ * 'id' => true, * 'nested' => [ * nested1 => true, * nested2 => true * ] * ] * * Warning: this method it is a naive implementation which does not take into account * conditional typed fragments. So use it with care for fields of interface and union types. * * @param int $depth How many levels to include in output * * @return array<string, mixed> * * @api */ function getFieldSelection(int $depth = 0): array","title":"GraphQL\\Type\\Definition\\ResolveInfo Methods"},{"location":"class-reference/#graphqllanguagedirectivelocation","text":"Enumeration of available directive locations.","title":"GraphQL\\Language\\DirectiveLocation"},{"location":"class-reference/#graphqllanguagedirectivelocation-constants","text":"const QUERY = 'QUERY'; const MUTATION = 'MUTATION'; const SUBSCRIPTION = 'SUBSCRIPTION'; const FIELD = 'FIELD'; const FRAGMENT_DEFINITION = 'FRAGMENT_DEFINITION'; const FRAGMENT_SPREAD = 'FRAGMENT_SPREAD'; const INLINE_FRAGMENT = 'INLINE_FRAGMENT'; const VARIABLE_DEFINITION = 'VARIABLE_DEFINITION'; const EXECUTABLE_LOCATIONS = [ 'QUERY' => 'QUERY', 'MUTATION' => 'MUTATION', 'SUBSCRIPTION' => 'SUBSCRIPTION', 'FIELD' => 'FIELD', 'FRAGMENT_DEFINITION' => 'FRAGMENT_DEFINITION', 'FRAGMENT_SPREAD' => 'FRAGMENT_SPREAD', 'INLINE_FRAGMENT' => 'INLINE_FRAGMENT', 'VARIABLE_DEFINITION' => 'VARIABLE_DEFINITION', ]; const SCHEMA = 'SCHEMA'; const SCALAR = 'SCALAR'; const OBJECT = 'OBJECT'; const FIELD_DEFINITION = 'FIELD_DEFINITION'; const ARGUMENT_DEFINITION = 'ARGUMENT_DEFINITION'; const IFACE = 'INTERFACE'; const UNION = 'UNION'; const ENUM = 'ENUM'; const ENUM_VALUE = 'ENUM_VALUE'; const INPUT_OBJECT = 'INPUT_OBJECT'; const INPUT_FIELD_DEFINITION = 'INPUT_FIELD_DEFINITION'; const TYPE_SYSTEM_LOCATIONS = [ 'SCHEMA' => 'SCHEMA', 'SCALAR' => 'SCALAR', 'OBJECT' => 'OBJECT', 'FIELD_DEFINITION' => 'FIELD_DEFINITION', 'ARGUMENT_DEFINITION' => 'ARGUMENT_DEFINITION', 'INTERFACE' => 'INTERFACE', 'UNION' => 'UNION', 'ENUM' => 'ENUM', 'ENUM_VALUE' => 'ENUM_VALUE', 'INPUT_OBJECT' => 'INPUT_OBJECT', 'INPUT_FIELD_DEFINITION' => 'INPUT_FIELD_DEFINITION', ]; const LOCATIONS = [ 'QUERY' => 'QUERY', 'MUTATION' => 'MUTATION', 'SUBSCRIPTION' => 'SUBSCRIPTION', 'FIELD' => 'FIELD', 'FRAGMENT_DEFINITION' => 'FRAGMENT_DEFINITION', 'FRAGMENT_SPREAD' => 'FRAGMENT_SPREAD', 'INLINE_FRAGMENT' => 'INLINE_FRAGMENT', 'VARIABLE_DEFINITION' => 'VARIABLE_DEFINITION', 'SCHEMA' => 'SCHEMA', 'SCALAR' => 'SCALAR', 'OBJECT' => 'OBJECT', 'FIELD_DEFINITION' => 'FIELD_DEFINITION', 'ARGUMENT_DEFINITION' => 'ARGUMENT_DEFINITION', 'INTERFACE' => 'INTERFACE', 'UNION' => 'UNION', 'ENUM' => 'ENUM', 'ENUM_VALUE' => 'ENUM_VALUE', 'INPUT_OBJECT' => 'INPUT_OBJECT', 'INPUT_FIELD_DEFINITION' => 'INPUT_FIELD_DEFINITION', ];","title":"GraphQL\\Language\\DirectiveLocation Constants"},{"location":"class-reference/#graphqltypeschemaconfig","text":"Configuration options for schema construction. The options accepted by the create method are described in the schema definition docs . Usage example: $config = SchemaConfig::create() ->setQuery($myQueryType) ->setTypeLoader($myTypeLoader); $schema = new Schema($config); @see Type, NamedType @phpstan-type TypeLoader callable(string $typeName):((Type&NamedType)|null) @phpstan-type Types array |callable():array","title":"GraphQL\\Type\\SchemaConfig"},{"location":"class-reference/#graphqltypeschemaconfig-methods","text":"/** * Converts an array of options to instance of SchemaConfig * (or just returns empty config when array is not passed). * * @param array<string, mixed> $options * * @api */ static function create(array $options = []): self /** * @api */ function getQuery(): ?GraphQL\\Type\\Definition\\ObjectType /** * @api */ function setQuery(?GraphQL\\Type\\Definition\\ObjectType $query): self /** * @api */ function getMutation(): ?GraphQL\\Type\\Definition\\ObjectType /** * @api */ function setMutation(?GraphQL\\Type\\Definition\\ObjectType $mutation): self /** * @api */ function getSubscription(): ?GraphQL\\Type\\Definition\\ObjectType /** * @api */ function setSubscription(?GraphQL\\Type\\Definition\\ObjectType $subscription): self /** * @return array|callable * @phpstan-return Types * * @api */ function getTypes() /** * @param array|callable $types * @phpstan-param Types $types * * @api */ function setTypes($types): self /** * @return array<Directive>|null * * @api */ function getDirectives(): ?array /** * @param array<Directive>|null $directives * * @api */ function setDirectives(?array $directives): self /** * @return callable|null $typeLoader * @phpstan-return TypeLoader|null $typeLoader * * @api */ function getTypeLoader(): ?callable /** * @phpstan-param TypeLoader|null $typeLoader * * @api */ function setTypeLoader(?callable $typeLoader): self","title":"GraphQL\\Type\\SchemaConfig Methods"},{"location":"class-reference/#graphqltypeschema","text":"Schema Definition (see schema definition docs ). A Schema is created by supplying the root types of each type of operation: query, mutation (optional) and subscription (optional). A schema definition is then supplied to the validator and executor. Usage Example: $schema = new GraphQL\\Type\\Schema([ 'query' => $MyAppQueryRootType, 'mutation' => $MyAppMutationRootType, ]); Or using Schema Config instance: $config = GraphQL\\Type\\SchemaConfig::create() ->setQuery($MyAppQueryRootType) ->setMutation($MyAppMutationRootType); $schema = new GraphQL\\Type\\Schema($config);","title":"GraphQL\\Type\\Schema"},{"location":"class-reference/#graphqltypeschema-methods","text":"/** * @param SchemaConfig|array<string, mixed> $config * * @api */ function __construct($config) /** * Returns all types in this schema. * * This operation requires a full schema scan. Do not use in production environment. * * @return array<string, Type&NamedType> Keys represent type names, values are instances of corresponding type definitions * * @api */ function getTypeMap(): array /** * Returns a list of directives supported by this schema. * * @return array<Directive> * * @api */ function getDirectives(): array /** * Returns root query type. * * @api */ function getQueryType(): ?GraphQL\\Type\\Definition\\ObjectType /** * Returns root mutation type. * * @api */ function getMutationType(): ?GraphQL\\Type\\Definition\\ObjectType /** * Returns schema subscription. * * @api */ function getSubscriptionType(): ?GraphQL\\Type\\Definition\\ObjectType /** * @api */ function getConfig(): GraphQL\\Type\\SchemaConfig /** * Returns a type by name. * * @return (Type&NamedType)|null * * @api */ function getType(string $name): ?GraphQL\\Type\\Definition\\Type /** * Returns all possible concrete types for given abstract type * (implementations for interfaces and members of union type for unions). * * This operation requires full schema scan. Do not use in production environment. * * @param AbstractType&Type $abstractType * * @return array<ObjectType> * * @api */ function getPossibleTypes(GraphQL\\Type\\Definition\\AbstractType $abstractType): array /** * Returns all types that implement a given interface type. * * This operation requires full schema scan. Do not use in production environment. * * @api */ function getImplementations(GraphQL\\Type\\Definition\\InterfaceType $abstractType): GraphQL\\Utils\\InterfaceImplementations /** * Returns true if the given type is a sub type of the given abstract type. * * @param AbstractType&Type $abstractType * @param ImplementingType&Type $maybeSubType * * @api */ function isSubType( GraphQL\\Type\\Definition\\AbstractType $abstractType, GraphQL\\Type\\Definition\\ImplementingType $maybeSubType ): bool /** * Returns instance of directive by name. * * @api */ function getDirective(string $name): ?GraphQL\\Type\\Definition\\Directive /** * Throws if the schema is not valid. * * This operation requires a full schema scan. Do not use in production environment. * * @throws InvariantViolation * * @api */ function assertValid(): void /** * Validate the schema and return any errors. * * This operation requires a full schema scan. Do not use in production environment. * * @return array<int, Error> * * @api */ function validate(): array","title":"GraphQL\\Type\\Schema Methods"},{"location":"class-reference/#graphqllanguageparser","text":"Parses string containing GraphQL query language or schema definition language to Abstract Syntax Tree. @phpstan-type ParserOptions array{ noLocation?: bool, allowLegacySDLEmptyFields?: bool, allowLegacySDLImplementsInterfaces?: bool, experimentalFragmentVariables?: bool } noLocation: (By default, the parser creates AST nodes that know the location in the source that they correspond to. This configuration flag disables that behavior for performance or testing.) allowLegacySDLEmptyFields: If enabled, the parser will parse empty fields sets in the Schema Definition Language. Otherwise, the parser will follow the current specification. This option is provided to ease adoption of the final SDL specification and will be removed in a future major release. allowLegacySDLImplementsInterfaces: If enabled, the parser will parse implemented interfaces with no & character between each interface. Otherwise, the parser will follow the current specification. This option is provided to ease adoption of the final SDL specification and will be removed in a future major release. experimentalFragmentVariables: (If enabled, the parser will understand and parse variable definitions contained in a fragment definition. They'll be represented in the variableDefinitions field of the FragmentDefinitionNode. The syntax is identical to normal, query-defined variables. For example: fragment A($var: Boolean = false) on T { ... } Note: this feature is experimental and may change or be removed in the future.) Those magic functions allow partial parsing: @method static NameNode name(Source|string $source, bool[] $options = []) @method static DocumentNode document(Source|string $source, bool[] $options = []) @method static ExecutableDefinitionNode|TypeSystemDefinitionNode definition(Source|string $source, bool[] $options = []) @method static ExecutableDefinitionNode executableDefinition(Source|string $source, bool[] $options = []) @method static OperationDefinitionNode operationDefinition(Source|string $source, bool[] $options = []) @method static string operationType(Source|string $source, bool[] $options = []) @method static NodeList variableDefinitions(Source|string $source, bool[] $options = []) @method static VariableDefinitionNode variableDefinition(Source|string $source, bool[] $options = []) @method static VariableNode variable(Source|string $source, bool[] $options = []) @method static SelectionSetNode selectionSet(Source|string $source, bool[] $options = []) @method static mixed selection(Source|string $source, bool[] $options = []) @method static FieldNode field(Source|string $source, bool[] $options = []) @method static NodeList arguments(Source|string $source, bool[] $options = []) @method static NodeList constArguments(Source|string $source, bool[] $options = []) @method static ArgumentNode argument(Source|string $source, bool[] $options = []) @method static ArgumentNode constArgument(Source|string $source, bool[] $options = []) @method static FragmentSpreadNode|InlineFragmentNode fragment(Source|string $source, bool[] $options = []) @method static FragmentDefinitionNode fragmentDefinition(Source|string $source, bool[] $options = []) @method static NameNode fragmentName(Source|string $source, bool[] $options = []) @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|NullValueNode|ObjectValueNode|StringValueNode|VariableNode valueLiteral(Source|string $source, bool[] $options = []) @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|NullValueNode|ObjectValueNode|StringValueNode constValueLiteral(Source|string $source, bool[] $options = []) @method static StringValueNode stringLiteral(Source|string $source, bool[] $options = []) @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|StringValueNode constValue(Source|string $source, bool[] $options = []) @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|ObjectValueNode|StringValueNode|VariableNode variableValue(Source|string $source, bool[] $options = []) @method static ListValueNode array(Source|string $source, bool[] $options = []) @method static ListValueNode constArray(Source|string $source, bool[] $options = []) @method static ObjectValueNode object(Source|string $source, bool[] $options = []) @method static ObjectValueNode constObject(Source|string $source, bool[] $options = []) @method static ObjectFieldNode objectField(Source|string $source, bool[] $options = []) @method static ObjectFieldNode constObjectField(Source|string $source, bool[] $options = []) @method static NodeList directives(Source|string $source, bool[] $options = []) @method static NodeList constDirectives(Source|string $source, bool[] $options = []) @method static DirectiveNode directive(Source|string $source, bool[] $options = []) @method static DirectiveNode constDirective(Source|string $source, bool[] $options = []) @method static ListTypeNode|NamedTypeNode|NonNullTypeNode typeReference(Source|string $source, bool[] $options = []) @method static NamedTypeNode namedType(Source|string $source, bool[] $options = []) @method static TypeSystemDefinitionNode typeSystemDefinition(Source|string $source, bool[] $options = []) @method static StringValueNode|null description(Source|string $source, bool[] $options = []) @method static SchemaDefinitionNode schemaDefinition(Source|string $source, bool[] $options = []) @method static OperationTypeDefinitionNode operationTypeDefinition(Source|string $source, bool[] $options = []) @method static ScalarTypeDefinitionNode scalarTypeDefinition(Source|string $source, bool[] $options = []) @method static ObjectTypeDefinitionNode objectTypeDefinition(Source|string $source, bool[] $options = []) @method static NodeList implementsInterfaces(Source|string $source, bool[] $options = []) @method static NodeList fieldsDefinition(Source|string $source, bool[] $options = []) @method static FieldDefinitionNode fieldDefinition(Source|string $source, bool[] $options = []) @method static NodeList argumentsDefinition(Source|string $source, bool[] $options = []) @method static InputValueDefinitionNode inputValueDefinition(Source|string $source, bool[] $options = []) @method static InterfaceTypeDefinitionNode interfaceTypeDefinition(Source|string $source, bool[] $options = []) @method static UnionTypeDefinitionNode unionTypeDefinition(Source|string $source, bool[] $options = []) @method static NodeList unionMemberTypes(Source|string $source, bool[] $options = []) @method static EnumTypeDefinitionNode enumTypeDefinition(Source|string $source, bool[] $options = []) @method static NodeList enumValuesDefinition(Source|string $source, bool[] $options = []) @method static EnumValueDefinitionNode enumValueDefinition(Source|string $source, bool[] $options = []) @method static InputObjectTypeDefinitionNode inputObjectTypeDefinition(Source|string $source, bool[] $options = []) @method static NodeList inputFieldsDefinition(Source|string $source, bool[] $options = []) @method static TypeExtensionNode typeExtension(Source|string $source, bool[] $options = []) @method static SchemaExtensionNode schemaTypeExtension(Source|string $source, bool[] $options = []) @method static ScalarTypeExtensionNode scalarTypeExtension(Source|string $source, bool[] $options = []) @method static ObjectTypeExtensionNode objectTypeExtension(Source|string $source, bool[] $options = []) @method static InterfaceTypeExtensionNode interfaceTypeExtension(Source|string $source, bool[] $options = []) @method static UnionTypeExtensionNode unionTypeExtension(Source|string $source, bool[] $options = []) @method static EnumTypeExtensionNode enumTypeExtension(Source|string $source, bool[] $options = []) @method static InputObjectTypeExtensionNode inputObjectTypeExtension(Source|string $source, bool[] $options = []) @method static DirectiveDefinitionNode directiveDefinition(Source|string $source, bool[] $options = []) @method static NodeList directiveLocations(Source|string $source, bool[] $options = []) @method static NameNode directiveLocation(Source|string $source, bool[] $options = [])","title":"GraphQL\\Language\\Parser"},{"location":"class-reference/#graphqllanguageparser-methods","text":"/** * Given a GraphQL source, parses it into a `GraphQL\\Language\\AST\\DocumentNode`. * * Throws `GraphQL\\Error\\SyntaxError` if a syntax error is encountered. * * @param Source|string $source * @phpstan-param ParserOptions $options * * @throws SyntaxError * * @api */ static function parse($source, array $options = []): GraphQL\\Language\\AST\\DocumentNode /** * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for that value. * * Throws `GraphQL\\Error\\SyntaxError` if a syntax error is encountered. * * This is useful within tools that operate upon GraphQL Values directly and * in isolation of complete GraphQL documents. * * Consider providing the results to the utility function: `GraphQL\\Utils\\AST::valueFromAST()`. * * @param Source|string $source * @phpstan-param ParserOptions $options * * @return BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|NullValueNode|ObjectValueNode|StringValueNode|VariableNode * * @api */ static function parseValue($source, array $options = []) /** * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for that type. * * Throws `GraphQL\\Error\\SyntaxError` if a syntax error is encountered. * * This is useful within tools that operate upon GraphQL Types directly and * in isolation of complete GraphQL documents. * * Consider providing the results to the utility function: `GraphQL\\Utils\\AST::typeFromAST()`. * * @param Source|string $source * @phpstan-param ParserOptions $options * * @return ListTypeNode|NamedTypeNode|NonNullTypeNode * * @api */ static function parseType($source, array $options = [])","title":"GraphQL\\Language\\Parser Methods"},{"location":"class-reference/#graphqllanguageprinter","text":"Prints AST to string. Capable of printing GraphQL queries and Type definition language. Useful for pretty-printing queries or printing back AST for logging, documentation, etc. Usage example: $query = 'query myQuery {someField}'; $ast = GraphQL\\Language\\Parser::parse($query); $printed = GraphQL\\Language\\Printer::doPrint($ast);","title":"GraphQL\\Language\\Printer"},{"location":"class-reference/#graphqllanguageprinter-methods","text":"/** * Converts the AST of a GraphQL node to a string. * * Handles both executable definitions and schema definitions. * * @api */ static function doPrint(GraphQL\\Language\\AST\\Node $ast): string","title":"GraphQL\\Language\\Printer Methods"},{"location":"class-reference/#graphqllanguagevisitor","text":"Utility for efficient AST traversal and modification. visit() will walk through an AST using a depth first traversal, calling the visitor's enter function at each node in the traversal, and calling the leave function after visiting that node and all of its child nodes. By returning different values from the enter and leave functions, the behavior of the visitor can be altered, including skipping over a sub-tree of the AST (by returning false), editing the AST by returning a value or null to remove the value, or to stop the whole traversal by returning BREAK. When using visit() to edit an AST, the original AST will not be modified, and a new version of the AST with the changes applied will be returned from the visit function. $editedAST = Visitor::visit($ast, [ 'enter' => function ($node, $key, $parent, $path, $ancestors) { // return // null: no action // Visitor::skipNode(): skip visiting this node // Visitor::stop(): stop visiting altogether // Visitor::removeNode(): delete this node // any value: replace this node with the returned value }, 'leave' => function ($node, $key, $parent, $path, $ancestors) { // return // null: no action // Visitor::stop(): stop visiting altogether // Visitor::removeNode(): delete this node // any value: replace this node with the returned value } ]); Alternatively to providing enter() and leave() functions, a visitor can instead provide functions named the same as the kinds of AST nodes , or enter/leave visitors at a named key, leading to four permutations of visitor API: Named visitors triggered when entering a node a specific kind. Visitor::visit($ast, [ 'Kind' => function ($node) { // enter the \"Kind\" node } ]); Named visitors that trigger upon entering and leaving a node of a specific kind. Visitor::visit($ast, [ 'Kind' => [ 'enter' => function ($node) { // enter the \"Kind\" node } 'leave' => function ($node) { // leave the \"Kind\" node } ] ]); Generic visitors that trigger upon entering and leaving any node. Visitor::visit($ast, [ 'enter' => function ($node) { // enter any node }, 'leave' => function ($node) { // leave any node } ]); Parallel visitors for entering and leaving nodes of a specific kind. Visitor::visit($ast, [ 'enter' => [ 'Kind' => function($node) { // enter the \"Kind\" node } }, 'leave' => [ 'Kind' => function ($node) { // leave the \"Kind\" node } ] ]); @phpstan-type VisitorArray array |array >","title":"GraphQL\\Language\\Visitor"},{"location":"class-reference/#graphqllanguagevisitor-methods","text":"/** * Visit the AST (see class description for details). * * @template TNode of Node * * @param NodeList<TNode>|Node $root * @param VisitorArray $visitor * @param array<string, mixed>|null $keyMap * * @throws Exception * * @return Node|mixed * * @api */ static function visit(object $root, array $visitor, ?array $keyMap = null) /** * Returns marker for stopping. * * @api */ static function stop(): GraphQL\\Language\\VisitorStop /** * Returns marker for skipping the current node. * * @api */ static function skipNode(): GraphQL\\Language\\VisitorSkipNode /** * Returns marker for removing the current node. * * @api */ static function removeNode(): GraphQL\\Language\\VisitorRemoveNode","title":"GraphQL\\Language\\Visitor Methods"},{"location":"class-reference/#graphqllanguageastnodekind","text":"Holds constants of possible AST nodes.","title":"GraphQL\\Language\\AST\\NodeKind"},{"location":"class-reference/#graphqllanguageastnodekind-constants","text":"const NAME = 'Name'; const DOCUMENT = 'Document'; const OPERATION_DEFINITION = 'OperationDefinition'; const VARIABLE_DEFINITION = 'VariableDefinition'; const VARIABLE = 'Variable'; const SELECTION_SET = 'SelectionSet'; const FIELD = 'Field'; const ARGUMENT = 'Argument'; const FRAGMENT_SPREAD = 'FragmentSpread'; const INLINE_FRAGMENT = 'InlineFragment'; const FRAGMENT_DEFINITION = 'FragmentDefinition'; const INT = 'IntValue'; const FLOAT = 'FloatValue'; const STRING = 'StringValue'; const BOOLEAN = 'BooleanValue'; const ENUM = 'EnumValue'; const NULL = 'NullValue'; const LST = 'ListValue'; const OBJECT = 'ObjectValue'; const OBJECT_FIELD = 'ObjectField'; const DIRECTIVE = 'Directive'; const NAMED_TYPE = 'NamedType'; const LIST_TYPE = 'ListType'; const NON_NULL_TYPE = 'NonNullType'; const SCHEMA_DEFINITION = 'SchemaDefinition'; const OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition'; const SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition'; const OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition'; const FIELD_DEFINITION = 'FieldDefinition'; const INPUT_VALUE_DEFINITION = 'InputValueDefinition'; const INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition'; const UNION_TYPE_DEFINITION = 'UnionTypeDefinition'; const ENUM_TYPE_DEFINITION = 'EnumTypeDefinition'; const ENUM_VALUE_DEFINITION = 'EnumValueDefinition'; const INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition'; const SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension'; const OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension'; const INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension'; const UNION_TYPE_EXTENSION = 'UnionTypeExtension'; const ENUM_TYPE_EXTENSION = 'EnumTypeExtension'; const INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension'; const DIRECTIVE_DEFINITION = 'DirectiveDefinition'; const SCHEMA_EXTENSION = 'SchemaExtension'; const CLASS_MAP = [ 'Name' => 'GraphQL\\\\Language\\\\AST\\\\NameNode', 'Document' => 'GraphQL\\\\Language\\\\AST\\\\DocumentNode', 'OperationDefinition' => 'GraphQL\\\\Language\\\\AST\\\\OperationDefinitionNode', 'VariableDefinition' => 'GraphQL\\\\Language\\\\AST\\\\VariableDefinitionNode', 'Variable' => 'GraphQL\\\\Language\\\\AST\\\\VariableNode', 'SelectionSet' => 'GraphQL\\\\Language\\\\AST\\\\SelectionSetNode', 'Field' => 'GraphQL\\\\Language\\\\AST\\\\FieldNode', 'Argument' => 'GraphQL\\\\Language\\\\AST\\\\ArgumentNode', 'FragmentSpread' => 'GraphQL\\\\Language\\\\AST\\\\FragmentSpreadNode', 'InlineFragment' => 'GraphQL\\\\Language\\\\AST\\\\InlineFragmentNode', 'FragmentDefinition' => 'GraphQL\\\\Language\\\\AST\\\\FragmentDefinitionNode', 'IntValue' => 'GraphQL\\\\Language\\\\AST\\\\IntValueNode', 'FloatValue' => 'GraphQL\\\\Language\\\\AST\\\\FloatValueNode', 'StringValue' => 'GraphQL\\\\Language\\\\AST\\\\StringValueNode', 'BooleanValue' => 'GraphQL\\\\Language\\\\AST\\\\BooleanValueNode', 'EnumValue' => 'GraphQL\\\\Language\\\\AST\\\\EnumValueNode', 'NullValue' => 'GraphQL\\\\Language\\\\AST\\\\NullValueNode', 'ListValue' => 'GraphQL\\\\Language\\\\AST\\\\ListValueNode', 'ObjectValue' => 'GraphQL\\\\Language\\\\AST\\\\ObjectValueNode', 'ObjectField' => 'GraphQL\\\\Language\\\\AST\\\\ObjectFieldNode', 'Directive' => 'GraphQL\\\\Language\\\\AST\\\\DirectiveNode', 'NamedType' => 'GraphQL\\\\Language\\\\AST\\\\NamedTypeNode', 'ListType' => 'GraphQL\\\\Language\\\\AST\\\\ListTypeNode', 'NonNullType' => 'GraphQL\\\\Language\\\\AST\\\\NonNullTypeNode', 'SchemaDefinition' => 'GraphQL\\\\Language\\\\AST\\\\SchemaDefinitionNode', 'OperationTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\OperationTypeDefinitionNode', 'ScalarTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\ScalarTypeDefinitionNode', 'ObjectTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\ObjectTypeDefinitionNode', 'FieldDefinition' => 'GraphQL\\\\Language\\\\AST\\\\FieldDefinitionNode', 'InputValueDefinition' => 'GraphQL\\\\Language\\\\AST\\\\InputValueDefinitionNode', 'InterfaceTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\InterfaceTypeDefinitionNode', 'UnionTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\UnionTypeDefinitionNode', 'EnumTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\EnumTypeDefinitionNode', 'EnumValueDefinition' => 'GraphQL\\\\Language\\\\AST\\\\EnumValueDefinitionNode', 'InputObjectTypeDefinition' => 'GraphQL\\\\Language\\\\AST\\\\InputObjectTypeDefinitionNode', 'ScalarTypeExtension' => 'GraphQL\\\\Language\\\\AST\\\\ScalarTypeExtensionNode', 'ObjectTypeExtension' => 'GraphQL\\\\Language\\\\AST\\\\ObjectTypeExtensionNode', 'InterfaceTypeExtension' => 'GraphQL\\\\Language\\\\AST\\\\InterfaceTypeExtensionNode', 'UnionTypeExtension' => 'GraphQL\\\\Language\\\\AST\\\\UnionTypeExtensionNode', 'EnumTypeExtension' => 'GraphQL\\\\Language\\\\AST\\\\EnumTypeExtensionNode', 'InputObjectTypeExtension' => 'GraphQL\\\\Language\\\\AST\\\\InputObjectTypeExtensionNode', 'DirectiveDefinition' => 'GraphQL\\\\Language\\\\AST\\\\DirectiveDefinitionNode', ];","title":"GraphQL\\Language\\AST\\NodeKind Constants"},{"location":"class-reference/#graphqlexecutorexecutor","text":"Implements the \"Evaluating requests\" section of the GraphQL specification. @phpstan-type FieldResolver callable(mixed, array , mixed, ResolveInfo): mixed @see https://github.com/vimeo/psalm/issues/6928 @psalm-type FieldResolver callable(mixed, array, mixed, ResolveInfo): mixed @phpstan-type ImplementationFactory callable(PromiseAdapter, Schema, DocumentNode, mixed, mixed, array , ?string, callable): ExecutorImplementation @see https://github.com/vimeo/psalm/issues/6928, https://github.com/vimeo/psalm/issues/7527 @psalm-type ImplementationFactory callable(PromiseAdapter, Schema, DocumentNode, mixed, mixed, array, ?string, callable): ExecutorImplementation","title":"GraphQL\\Executor\\Executor"},{"location":"class-reference/#graphqlexecutorexecutor-methods","text":"/** * Executes DocumentNode against given $schema. * * Always returns ExecutionResult and never throws. * All errors which occur during operation execution are collected in `$result->errors`. * * @param mixed $rootValue * @param mixed $contextValue * @param array<string, mixed>|null $variableValues * @phpstan-param FieldResolver|null $fieldResolver * * @api */ static function execute( GraphQL\\Type\\Schema $schema, GraphQL\\Language\\AST\\DocumentNode $documentNode, $rootValue = null, $contextValue = null, ?array $variableValues = null, ?string $operationName = null, ?callable $fieldResolver = null ): GraphQL\\Executor\\ExecutionResult /** * Same as execute(), but requires promise adapter and returns a promise which is always * fulfilled with an instance of ExecutionResult and never rejected. * * Useful for async PHP platforms. * * @param mixed $rootValue * @param mixed $contextValue * @param array<string, mixed>|null $variableValues * @phpstan-param FieldResolver|null $fieldResolver * * @api */ static function promiseToExecute( GraphQL\\Executor\\Promise\\PromiseAdapter $promiseAdapter, GraphQL\\Type\\Schema $schema, GraphQL\\Language\\AST\\DocumentNode $documentNode, $rootValue = null, $contextValue = null, ?array $variableValues = null, ?string $operationName = null, ?callable $fieldResolver = null ): GraphQL\\Executor\\Promise\\Promise","title":"GraphQL\\Executor\\Executor Methods"},{"location":"class-reference/#graphqlexecutorexecutionresult","text":"Returned after query execution . Represents both - result of successful execution and of a failed one (with errors collected in errors prop). Could be converted to spec-compliant serializable array using toArray() . @see Throwable @phpstan-type SerializableError array{ message: string, locations?: array , path?: array , extensions?: array } @phpstan-type SerializableErrors array @phpstan-type SerializableResult array{ data?: array , errors?: SerializableErrors, extensions?: array } @phpstan-type ErrorFormatter callable(Throwable): SerializableError @phpstan-type ErrorsHandler callable(array $errors, ErrorFormatter $formatter): SerializableErrors @see https://github.com/vimeo/psalm/issues/6928 @psalm-type ErrorsHandler callable(Error[], ErrorFormatter): SerializableErrors","title":"GraphQL\\Executor\\ExecutionResult"},{"location":"class-reference/#graphqlexecutorexecutionresult-props","text":"/** * Data collected from resolvers during query execution. * * @api * * @var array<string, mixed>|null */ public $data; /** * Errors registered during query execution. * * If an error was caused by exception thrown in resolver, $error->getPrevious() would * contain original exception. * * @api * * @var array<Error> */ public $errors; /** * User-defined serializable array of extensions included in serialized result. * * @api * * @var array<string, mixed>|null */ public $extensions;","title":"GraphQL\\Executor\\ExecutionResult Props"},{"location":"class-reference/#graphqlexecutorexecutionresult-methods","text":"/** * Define custom error formatting (must conform to http://facebook.github.io/graphql/#sec-Errors). * * Expected signature is: function (GraphQL\\Error\\Error $error): array * * Default formatter is \"GraphQL\\Error\\FormattedError::createFromException\" * * Expected returned value must be an array: * array( * 'message' => 'errorMessage', * // ... other keys * ); * * @phpstan-param ErrorFormatter|null $errorFormatter * * @api */ function setErrorFormatter(?callable $errorFormatter): self /** * Define custom logic for error handling (filtering, logging, etc). * * Expected handler signature is: * fn (array $errors, callable $formatter): array * * Default handler is: * fn (array $errors, callable $formatter): array => array_map($formatter, $errors) * * @phpstan-param ErrorsHandler|null $errorsHandler * * @api */ function setErrorsHandler(?callable $errorsHandler): self /** * Converts GraphQL query result to spec-compliant serializable array using provided * errors handler and formatter. * * If debug argument is passed, output of error formatter is enriched which debugging information * (\"debugMessage\", \"trace\" keys depending on flags). * * $debug argument must sum of flags from @see \\GraphQL\\Error\\DebugFlag * * @phpstan-return SerializableResult * * @api */ function toArray(int $debug = 'GraphQL\\\\Error\\\\DebugFlag::NONE'): array","title":"GraphQL\\Executor\\ExecutionResult Methods"},{"location":"class-reference/#graphqlexecutorpromisepromiseadapter","text":"Provides a means for integration of async PHP platforms ( related docs ).","title":"GraphQL\\Executor\\Promise\\PromiseAdapter"},{"location":"class-reference/#graphqlexecutorpromisepromiseadapter-methods","text":"/** * Is the value a promise or a deferred of the underlying platform? * * @param mixed $value * * @api */ function isThenable($value): bool /** * Converts thenable of the underlying platform into GraphQL\\Executor\\Promise\\Promise instance. * * @param mixed $thenable * * @api */ function convertThenable($thenable): GraphQL\\Executor\\Promise\\Promise /** * Accepts our Promise wrapper, extracts adopted promise out of it and executes actual `then` logic described * in Promises/A+ specs. Then returns new wrapped instance of GraphQL\\Executor\\Promise\\Promise. * * @api */ function then( GraphQL\\Executor\\Promise\\Promise $promise, ?callable $onFulfilled = null, ?callable $onRejected = null ): GraphQL\\Executor\\Promise\\Promise /** * Creates a Promise from the given resolver callable. * * @param callable(callable $resolve, callable $reject): void $resolver * * @api */ function create(callable $resolver): GraphQL\\Executor\\Promise\\Promise /** * Creates a fulfilled Promise for a value if the value is not a promise. * * @param mixed $value * * @api */ function createFulfilled($value = null): GraphQL\\Executor\\Promise\\Promise /** * Creates a rejected promise for a reason if the reason is not a promise. * * If the provided reason is a promise, then it is returned as-is. * * @api */ function createRejected(Throwable $reason): GraphQL\\Executor\\Promise\\Promise /** * Given an iterable of promises (or values), returns a promise that is fulfilled when all the * items in the iterable are fulfilled. * * @param iterable<Promise|mixed> $promisesOrValues * * @api */ function all(iterable $promisesOrValues): GraphQL\\Executor\\Promise\\Promise","title":"GraphQL\\Executor\\Promise\\PromiseAdapter Methods"},{"location":"class-reference/#graphqlvalidatordocumentvalidator","text":"Implements the \"Validation\" section of the spec. Validation runs synchronously, returning an array of encountered errors, or an empty array if no errors were encountered and the document is valid. A list of specific validation rules may be provided. If not provided, the default list of rules defined by the GraphQL specification will be used. Each validation rule is an instance of GraphQL\\Validator\\Rules\\ValidationRule which returns a visitor (see the GraphQL\\Language\\Visitor API ). Visitor methods are expected to return an instance of GraphQL\\Error\\Error , or array of such instances when invalid. Optionally a custom TypeInfo instance may be provided. If not provided, one will be created from the provided schema.","title":"GraphQL\\Validator\\DocumentValidator"},{"location":"class-reference/#graphqlvalidatordocumentvalidator-methods","text":"/** * Validate a GraphQL query against a schema. * * @param array<ValidationRule>|null $rules * * @return array<int, Error> * * @api */ static function validate( GraphQL\\Type\\Schema $schema, GraphQL\\Language\\AST\\DocumentNode $ast, ?array $rules = null, ?GraphQL\\Utils\\TypeInfo $typeInfo = null ): array /** * Returns all global validation rules. * * @return array<string, ValidationRule> * * @api */ static function allRules(): array /** * Returns global validation rule by name. * * Standard rules are named by class name, so example usage for such rules: * * @example DocumentValidator::getRule(GraphQL\\Validator\\Rules\\QueryComplexity::class); * * @api */ static function getRule(string $name): ?GraphQL\\Validator\\Rules\\ValidationRule /** * Add rule to list of global validation rules. * * @api */ static function addRule(GraphQL\\Validator\\Rules\\ValidationRule $rule): void /** * Remove rule from list of global validation rules. * * @api */ static function removeRule(GraphQL\\Validator\\Rules\\ValidationRule $rule): void","title":"GraphQL\\Validator\\DocumentValidator Methods"},{"location":"class-reference/#graphqlerrorerror","text":"Describes an Error found during the parse, validate, or execute phases of performing a GraphQL operation. In addition to a message and stack trace, it also includes information about the locations in a GraphQL document and/or execution result that correspond to the Error. When the error was caused by an exception thrown in resolver, original exception is available via getPrevious() . Also read related docs on error handling Class extends standard PHP \\Exception , so all standard methods of base \\Exception class are available in addition to those listed below.","title":"GraphQL\\Error\\Error"},{"location":"class-reference/#graphqlerrorerror-methods","text":"/** * An array of locations within the source GraphQL document which correspond to this error. * * Each entry has information about `line` and `column` within source GraphQL document: * $location->line; * $location->column; * * Errors during validation often contain multiple locations, for example to * point out to field mentioned in multiple fragments. Errors during execution include a * single location, the field which produced the error. * * @return array<int, SourceLocation> * * @api */ function getLocations(): array /** * Returns an array describing the path from the root value to the field which produced this error. * Only included for execution errors. * * @return array<int, int|string>|null * * @api */ function getPath(): ?array","title":"GraphQL\\Error\\Error Methods"},{"location":"class-reference/#graphqlerrorwarning","text":"Encapsulates warnings produced by the library. Warnings can be suppressed (individually or all) if required. Also, it is possible to override warning handler (which is trigger_error() by default). @phpstan-type WarningHandler callable(string $errorMessage, int $warningId, ?int $messageLevel): void @see https://github.com/vimeo/psalm/issues/7527 @psalm-type WarningHandler callable(string, int, int|null): void","title":"GraphQL\\Error\\Warning"},{"location":"class-reference/#graphqlerrorwarning-constants","text":"const NONE = 0; const WARNING_ASSIGN = 2; const WARNING_CONFIG = 4; const WARNING_FULL_SCHEMA_SCAN = 8; const WARNING_CONFIG_DEPRECATION = 16; const WARNING_NOT_A_TYPE = 32; const ALL = 63;","title":"GraphQL\\Error\\Warning Constants"},{"location":"class-reference/#graphqlerrorwarning-methods","text":"/** * Sets warning handler which can intercept all system warnings. * When not set, trigger_error() is used to notify about warnings. * * @phpstan-param WarningHandler|null $warningHandler * * @api */ static function setWarningHandler(?callable $warningHandler = null): void /** * Suppress warning by id (has no effect when custom warning handler is set). * * @param bool|int $suppress * * @example Warning::suppress(Warning::WARNING_NOT_A_TYPE) suppress a specific warning * @example Warning::suppress(true) suppresses all warnings * @example Warning::suppress(false) enables all warnings * * @api */ static function suppress($suppress = true): void /** * Re-enable previously suppressed warning by id (has no effect when custom warning handler is set). * * @param bool|int $enable * * @example Warning::suppress(Warning::WARNING_NOT_A_TYPE) re-enables a specific warning * @example Warning::suppress(true) re-enables all warnings * @example Warning::suppress(false) suppresses all warnings * * @api */ static function enable($enable = true): void","title":"GraphQL\\Error\\Warning Methods"},{"location":"class-reference/#graphqlerrorclientaware","text":"Implementing ClientAware allows graphql-php to decide if this error is safe to be shown to clients. Only errors that both implement this interface and return true from isClientSafe() will retain their original error message during formatting. All other errors will have their message replaced with \"Internal server error\".","title":"GraphQL\\Error\\ClientAware"},{"location":"class-reference/#graphqlerrorclientaware-methods","text":"/** * Is it safe to show the error message to clients? * * @api */ function isClientSafe(): bool","title":"GraphQL\\Error\\ClientAware Methods"},{"location":"class-reference/#graphqlerrordebugflag","text":"Collection of flags for error debugging .","title":"GraphQL\\Error\\DebugFlag"},{"location":"class-reference/#graphqlerrordebugflag-constants","text":"const NONE = 0; const INCLUDE_DEBUG_MESSAGE = 1; const INCLUDE_TRACE = 2; const RETHROW_INTERNAL_EXCEPTIONS = 4; const RETHROW_UNSAFE_EXCEPTIONS = 8;","title":"GraphQL\\Error\\DebugFlag Constants"},{"location":"class-reference/#graphqlerrorformattederror","text":"This class is used for default error formatting . It converts PHP exceptions to spec-compliant errors and provides tools for error debugging. @see ExecutionResult @phpstan-import-type SerializableError from ExecutionResult @phpstan-import-type ErrorFormatter from ExecutionResult","title":"GraphQL\\Error\\FormattedError"},{"location":"class-reference/#graphqlerrorformattederror-methods","text":"/** * Set default error message for internal errors formatted using createFormattedError(). * This value can be overridden by passing 3rd argument to `createFormattedError()`. * * @api */ static function setInternalErrorMessage(string $msg): void /** * Convert any exception to a GraphQL spec compliant array. * * This method only exposes the exception message when the given exception * implements the ClientAware interface, or when debug flags are passed. * * For a list of available debug flags @see \\GraphQL\\Error\\DebugFlag constants. * * @return SerializableError * * @api */ static function createFromException( Throwable $exception, int $debugFlag = 'GraphQL\\\\Error\\\\DebugFlag::NONE', ?string $internalErrorMessage = null ): array /** * Returns error trace as serializable array. * * @return array<int, array{ * file?: string, * line?: int, * function?: string, * call?: string, * }> * * @api */ static function toSafeTrace(Throwable $error): array","title":"GraphQL\\Error\\FormattedError Methods"},{"location":"class-reference/#graphqlserverstandardserver","text":"GraphQL server compatible with both: express-graphql and Apollo Server . Usage Example:. $server = new StandardServer([ 'schema' => $mySchema ]); $server->handleRequest(); Or using ServerConfig instance: $config = GraphQL\\Server\\ServerConfig::create() ->setSchema($mySchema) ->setContext($myContext); $server = new GraphQL\\Server\\StandardServer($config); $server->handleRequest(); See dedicated section in docs for details.","title":"GraphQL\\Server\\StandardServer"},{"location":"class-reference/#graphqlserverstandardserver-methods","text":"/** * Converts and exception to error and sends spec-compliant HTTP 500 error. * Useful when an exception is thrown somewhere outside of server execution context * (e.g. during schema instantiation). * * @api */ static function send500Error(Throwable $error, int $debug = 'GraphQL\\\\Error\\\\DebugFlag::NONE'): void /** * Creates new instance of a standard GraphQL HTTP server. * * @param ServerConfig|array<string, mixed> $config * * @api */ function __construct($config) /** * Parses HTTP request, executes and emits response (using standard PHP `header` function and `echo`). * * By default (when $parsedBody is not set) it uses PHP globals to parse a request. * It is possible to implement request parsing elsewhere (e.g. using framework Request instance) * and then pass it to the server. * * See `executeRequest()` if you prefer to emit response yourself * (e.g. using Response object of some framework) * * @param OperationParams|array<OperationParams> $parsedBody * * @api */ function handleRequest($parsedBody = null): void /** * Executes GraphQL operation and returns execution result * (or promise when promise adapter is different from SyncPromiseAdapter). * * By default (when $parsedBody is not set) it uses PHP globals to parse a request. * It is possible to implement request parsing elsewhere (e.g. using framework Request instance) * and then pass it to the server. * * PSR-7 compatible method executePsrRequest() does exactly this. * * @param OperationParams|array<OperationParams> $parsedBody * * @throws InvariantViolation * * @return ExecutionResult|array<int, ExecutionResult>|Promise * * @api */ function executeRequest($parsedBody = null) /** * Executes PSR-7 request and fulfills PSR-7 response. * * See `executePsrRequest()` if you prefer to create response yourself * (e.g. using specific JsonResponse instance of some framework). * * @return ResponseInterface|Promise * * @api */ function processPsrRequest( Psr\\Http\\Message\\RequestInterface $request, Psr\\Http\\Message\\ResponseInterface $response, Psr\\Http\\Message\\StreamInterface $writableBodyStream ) /** * Executes GraphQL operation and returns execution result * (or promise when promise adapter is different from SyncPromiseAdapter). * * @return ExecutionResult|array<int, ExecutionResult>|Promise * * @api */ function executePsrRequest(Psr\\Http\\Message\\RequestInterface $request) /** * Returns an instance of Server helper, which contains most of the actual logic for * parsing / validating / executing request (which could be re-used by other server implementations). * * @api */ function getHelper(): GraphQL\\Server\\Helper","title":"GraphQL\\Server\\StandardServer Methods"},{"location":"class-reference/#graphqlserverserverconfig","text":"Server configuration class. Could be passed directly to server constructor. List of options accepted by create method is described in docs . Usage example: $config = GraphQL\\Server\\ServerConfig::create() ->setSchema($mySchema) ->setContext($myContext); $server = new GraphQL\\Server\\StandardServer($config); @see ExecutionResult @phpstan-type PersistedQueryLoader callable(string $queryId, OperationParams $operation): (string|DocumentNode) @phpstan-type RootValueResolver callable(OperationParams $operation, DocumentNode $doc, string $operationType): mixed @phpstan-type ValidationRulesOption array |null|callable(OperationParams $operation, DocumentNode $doc, string $operationType): array @phpstan-import-type ErrorsHandler from ExecutionResult @phpstan-import-type ErrorFormatter from ExecutionResult","title":"GraphQL\\Server\\ServerConfig"},{"location":"class-reference/#graphqlserverserverconfig-methods","text":"/** * Converts an array of options to instance of ServerConfig * (or just returns empty config when array is not passed). * * @param array<string, mixed> $config * * @api */ static function create(array $config = []): self /** * @api */ function setSchema(GraphQL\\Type\\Schema $schema): self /** * @param mixed|callable $context * * @api */ function setContext($context): self /** * @param mixed|callable $rootValue * @phpstan-param mixed|RootValueResolver $rootValue * * @api */ function setRootValue($rootValue): self /** * @phpstan-param ErrorFormatter $errorFormatter * * @api */ function setErrorFormatter(callable $errorFormatter): self /** * @phpstan-param ErrorsHandler $handler * * @api */ function setErrorsHandler(callable $handler): self /** * Set validation rules for this server. * * @param array<ValidationRule>|callable|null $validationRules * @phpstan-param ValidationRulesOption $validationRules * * @api */ function setValidationRules($validationRules): self /** * @api */ function setFieldResolver(callable $fieldResolver): self /** * @phpstan-param PersistedQueryLoader|null $persistedQueryLoader * * @api */ function setPersistedQueryLoader(?callable $persistedQueryLoader): self /** * Set response debug flags. * * @see \\GraphQL\\Error\\DebugFlag class for a list of all available flags * * @api */ function setDebugFlag(int $debugFlag = 'GraphQL\\\\Error\\\\DebugFlag::INCLUDE_DEBUG_MESSAGE'): self /** * Allow batching queries (disabled by default). * * @api */ function setQueryBatching(bool $enableBatching): self /** * @api */ function setPromiseAdapter(GraphQL\\Executor\\Promise\\PromiseAdapter $promiseAdapter): self","title":"GraphQL\\Server\\ServerConfig Methods"},{"location":"class-reference/#graphqlserverhelper","text":"Contains functionality that could be re-used by various server implementations.","title":"GraphQL\\Server\\Helper"},{"location":"class-reference/#graphqlserverhelper-methods","text":"/** * Parses HTTP request using PHP globals and returns GraphQL OperationParams * contained in this request. For batched requests it returns an array of OperationParams. * * This function does not check validity of these params * (validation is performed separately in validateOperationParams() method). * * If $readRawBodyFn argument is not provided - will attempt to read raw request body * from `php://input` stream. * * Internally it normalizes input to $method, $bodyParams and $queryParams and * calls `parseRequestParams()` to produce actual return value. * * For PSR-7 request parsing use `parsePsrRequest()` instead. * * @throws RequestError * * @return OperationParams|array<int, OperationParams> * * @api */ function parseHttpRequest(?callable $readRawBodyFn = null) /** * Parses normalized request params and returns instance of OperationParams * or array of OperationParams in case of batch operation. * * Returned value is a suitable input for `executeOperation` or `executeBatch` (if array) * * @param array<mixed> $bodyParams * @param array<mixed> $queryParams * * @throws RequestError * * @return OperationParams|array<int, OperationParams> * * @api */ function parseRequestParams(string $method, array $bodyParams, array $queryParams) /** * Checks validity of OperationParams extracted from HTTP request and returns an array of errors * if params are invalid (or empty array when params are valid). * * @return array<int, RequestError> * * @api */ function validateOperationParams(GraphQL\\Server\\OperationParams $params): array /** * Executes GraphQL operation with given server configuration and returns execution result * (or promise when promise adapter is different from SyncPromiseAdapter). * * @return ExecutionResult|Promise * * @api */ function executeOperation(GraphQL\\Server\\ServerConfig $config, GraphQL\\Server\\OperationParams $op) /** * Executes batched GraphQL operations with shared promise queue * (thus, effectively batching deferreds|promises of all queries at once). * * @param array<OperationParams> $operations * * @return array<int, ExecutionResult>|Promise * * @api */ function executeBatch(GraphQL\\Server\\ServerConfig $config, array $operations) /** * Send response using standard PHP `header()` and `echo`. * * @param Promise|ExecutionResult|array<ExecutionResult> $result * * @api */ function sendResponse($result): void /** * Converts PSR-7 request to OperationParams or an array thereof. * * @throws RequestError * * @return OperationParams|array<OperationParams> * * @api */ function parsePsrRequest(Psr\\Http\\Message\\RequestInterface $request) /** * Converts query execution result to PSR-7 response. * * @param Promise|ExecutionResult|array<ExecutionResult> $result * * @return Promise|ResponseInterface * * @api */ function toPsrResponse( $result, Psr\\Http\\Message\\ResponseInterface $response, Psr\\Http\\Message\\StreamInterface $writableBodyStream )","title":"GraphQL\\Server\\Helper Methods"},{"location":"class-reference/#graphqlserveroperationparams","text":"Structure representing parsed HTTP parameters for GraphQL operation. The properties in this class are not strictly typed, as this class is only meant to serve as an intermediary representation which is not yet validated.","title":"GraphQL\\Server\\OperationParams"},{"location":"class-reference/#graphqlserveroperationparams-props","text":"/** * Id of the query (when using persisted queries). * * Valid aliases (case-insensitive): * - id * - queryId * - documentId * * @api * * @var mixed should be string|null */ public $queryId; /** * A document containing GraphQL operations and fragments to execute. * * @api * * @var mixed should be string|null */ public $query; /** * The name of the operation in the document to execute. * * @api * * @var mixed should be string|null */ public $operation; /** * Values for any variables defined by the operation. * * @api * * @var mixed should be array<string, mixed> */ public $variables; /** * Reserved for implementors to extend the protocol however they see fit. * * @api * * @var mixed should be array<string, mixed> */ public $extensions; /** * Executed in read-only context (e.g. via HTTP GET request)? * * @api */ public $readOnly; /** * The raw params used to construct this instance. * * @api * * @var array<string, mixed> */ public $originalInput;","title":"GraphQL\\Server\\OperationParams Props"},{"location":"class-reference/#graphqlserveroperationparams-methods","text":"/** * Creates an instance from given array. * * @param array<string, mixed> $params * * @api */ static function create(array $params, bool $readonly = false): GraphQL\\Server\\OperationParams","title":"GraphQL\\Server\\OperationParams Methods"},{"location":"class-reference/#graphqlutilsbuildschema","text":"Build instance of @see \\GraphQL\\Type\\Schema out of schema language definition (string or parsed AST). See schema definition language docs for details. @phpstan-import-type TypeConfigDecorator from ASTDefinitionBuilder @phpstan-type BuildSchemaOptions array{ assumeValid?: bool, assumeValidSDL?: bool } assumeValid: When building a schema from a GraphQL service's introspection result, it might be safe to assume the schema is valid. Set to true to assume the produced schema is valid. Default: false assumeValidSDL: Set to true to assume the SDL is valid. Default: false","title":"GraphQL\\Utils\\BuildSchema"},{"location":"class-reference/#graphqlutilsbuildschema-methods","text":"/** * A helper function to build a GraphQLSchema directly from a source * document. * * @param DocumentNode|Source|string $source * @phpstan-param TypeConfigDecorator|null $typeConfigDecorator * * @param array<string, bool> $options * @phpstan-param BuildSchemaOptions $options * * @api */ static function build($source, ?callable $typeConfigDecorator = null, array $options = []): GraphQL\\Type\\Schema /** * This takes the AST of a schema from @see \\GraphQL\\Language\\Parser::parse(). * * If no schema definition is provided, then it will look for types named Query and Mutation. * * Given that AST it constructs a @see \\GraphQL\\Type\\Schema. The resulting schema * has no resolve methods, so execution will use default resolvers. * * @phpstan-param TypeConfigDecorator|null $typeConfigDecorator * * @param array<string, bool> $options * @phpstan-param BuildSchemaOptions $options * * @throws Error * * @api */ static function buildAST( GraphQL\\Language\\AST\\DocumentNode $ast, ?callable $typeConfigDecorator = null, array $options = [] ): GraphQL\\Type\\Schema","title":"GraphQL\\Utils\\BuildSchema Methods"},{"location":"class-reference/#graphqlutilsast","text":"Various utilities dealing with AST.","title":"GraphQL\\Utils\\AST"},{"location":"class-reference/#graphqlutilsast-methods","text":"/** * Convert representation of AST as an associative array to instance of GraphQL\\Language\\AST\\Node. * * For example: * * ```php * AST::fromArray([ * 'kind' => 'ListValue', * 'values' => [ * ['kind' => 'StringValue', 'value' => 'my str'], * ['kind' => 'StringValue', 'value' => 'my other str'] * ], * 'loc' => ['start' => 21, 'end' => 25] * ]); * ``` * * Will produce instance of `ListValueNode` where `values` prop is a lazily-evaluated `NodeList` * returning instances of `StringValueNode` on access. * * This is a reverse operation for AST::toArray($node) * * @param array<string, mixed> $node * * @api */ static function fromArray(array $node): GraphQL\\Language\\AST\\Node /** * Convert AST node to serializable array. * * @return array<string, mixed> * * @api */ static function toArray(GraphQL\\Language\\AST\\Node $node): array /** * Produces a GraphQL Value AST given a PHP value. * * Optionally, a GraphQL type may be provided, which will be used to * disambiguate between value primitives. * * | PHP Value | GraphQL Value | * | ------------- | -------------------- | * | Object | Input Object | * | Assoc Array | Input Object | * | Array | List | * | Boolean | Boolean | * | String | String / Enum Value | * | Int | Int | * | Float | Int / Float | * | Mixed | Enum Value | * | null | NullValue | * * @param mixed $value * @param InputType&Type $type * * @return (ValueNode&Node)|null * * @api */ static function astFromValue($value, GraphQL\\Type\\Definition\\InputType $type): ?GraphQL\\Language\\AST\\ValueNode /** * Produces a PHP value given a GraphQL Value AST. * * A GraphQL type must be provided, which will be used to interpret different * GraphQL Value literals. * * Returns `null` when the value could not be validly coerced according to * the provided type. * * | GraphQL Value | PHP Value | * | -------------------- | ------------- | * | Input Object | Assoc Array | * | List | Array | * | Boolean | Boolean | * | String | String | * | Int / Float | Int / Float | * | Enum Value | Mixed | * | Null Value | null | * * @param (ValueNode&Node)|null $valueNode * @param array<string, mixed>|null $variables * * @throws Exception * * @return mixed * * @api */ static function valueFromAST( ?GraphQL\\Language\\AST\\ValueNode $valueNode, GraphQL\\Type\\Definition\\Type $type, ?array $variables = null ) /** * Produces a PHP value given a GraphQL Value AST. * * Unlike `valueFromAST()`, no type is provided. The resulting PHP value * will reflect the provided GraphQL value AST. * * | GraphQL Value | PHP Value | * | -------------------- | ------------- | * | Input Object | Assoc Array | * | List | Array | * | Boolean | Boolean | * | String | String | * | Int / Float | Int / Float | * | Enum | Mixed | * | Null | null | * * @param array<string, mixed>|null $variables * * @throws Exception * * @return mixed * * @api */ static function valueFromASTUntyped(GraphQL\\Language\\AST\\Node $valueNode, ?array $variables = null) /** * Returns type definition for given AST Type node. * * @param callable(string): ?Type $typeLoader * @param NamedTypeNode|ListTypeNode|NonNullTypeNode $inputTypeNode * * @throws Exception * * @api */ static function typeFromAST(callable $typeLoader, GraphQL\\Language\\AST\\Node $inputTypeNode): ?GraphQL\\Type\\Definition\\Type /** * Returns the operation within a document by name. * * If a name is not provided, an operation is only returned if the document has exactly one. * * @api */ static function getOperationAST(GraphQL\\Language\\AST\\DocumentNode $document, ?string $operationName = null): ?GraphQL\\Language\\AST\\OperationDefinitionNode /** * Provided a collection of ASTs, presumably each from different files, * concatenate the ASTs together into batched AST, useful for validating many * GraphQL source files which together represent one conceptual application. * * @param array<DocumentNode> $documents * * @api */ static function concatAST(array $documents): GraphQL\\Language\\AST\\DocumentNode","title":"GraphQL\\Utils\\AST Methods"},{"location":"class-reference/#graphqlutilsschemaprinter","text":"Prints the contents of a Schema in schema definition language. @phpstan-type Options array{sortTypes?: bool}","title":"GraphQL\\Utils\\SchemaPrinter"},{"location":"class-reference/#graphqlutilsschemaprinter-methods","text":"/** * @param array<string, bool> $options * @phpstan-param Options $options * * @api */ static function doPrint(GraphQL\\Type\\Schema $schema, array $options = []): string /** * @param array<string, bool> $options * @phpstan-param Options $options * * @api */ static function printIntrospectionSchema(GraphQL\\Type\\Schema $schema, array $options = []): string","title":"GraphQL\\Utils\\SchemaPrinter Methods"},{"location":"complementary-tools/","text":"Server Integrations \u00b6 Standard Server \u2013 Out of the box integration with any PSR-7 compatible framework (like Slim or Laminas Mezzio ) Lighthouse \u2013 Laravel package, SDL-first Laravel GraphQL - Laravel package, code-first OverblogGraphQLBundle \u2013 Symfony bundle WP-GraphQL - WordPress plugin Siler - Flat files and plain-old PHP functions, supports Swoole API Platform - Creates a GraphQL API from PHP models Server Utilities \u00b6 GraphQLite \u2013 Use PHP Annotations to define your schema GraphQL Doctrine \u2013 Define types with Doctrine ORM annotations DataLoaderPHP \u2013 Implements deferred resolvers GraphQL Upload \u2013 PSR-15 middleware to support file uploads in GraphQL GraphQL Batch Processor \u2013 Provides a builder interface for defining collection, querying, filtering, and post-processing logic of batched data fetches GraphQL Utils \u2013 Objective schema definition builders (no need for arrays anymore) and DateTime scalar Relay Library \u2013 Helps construct Relay related schema definitions MLL Scalars - Collection of custom scalar types GraphQL Clients \u00b6 GraphiQL \u2013 Graphical interactive in-browser GraphQL IDE GraphQL Playground \u2013 GraphQL IDE for better development workflows (GraphQL Subscriptions, interactive docs & collaboration) Altair GraphQL Client - Beautiful feature-rich GraphQL Client for all platforms Sailor - Typesafe GraphQL client for PHP","title":"Complementary Tools"},{"location":"complementary-tools/#server-integrations","text":"Standard Server \u2013 Out of the box integration with any PSR-7 compatible framework (like Slim or Laminas Mezzio ) Lighthouse \u2013 Laravel package, SDL-first Laravel GraphQL - Laravel package, code-first OverblogGraphQLBundle \u2013 Symfony bundle WP-GraphQL - WordPress plugin Siler - Flat files and plain-old PHP functions, supports Swoole API Platform - Creates a GraphQL API from PHP models","title":"Server Integrations"},{"location":"complementary-tools/#server-utilities","text":"GraphQLite \u2013 Use PHP Annotations to define your schema GraphQL Doctrine \u2013 Define types with Doctrine ORM annotations DataLoaderPHP \u2013 Implements deferred resolvers GraphQL Upload \u2013 PSR-15 middleware to support file uploads in GraphQL GraphQL Batch Processor \u2013 Provides a builder interface for defining collection, querying, filtering, and post-processing logic of batched data fetches GraphQL Utils \u2013 Objective schema definition builders (no need for arrays anymore) and DateTime scalar Relay Library \u2013 Helps construct Relay related schema definitions MLL Scalars - Collection of custom scalar types","title":"Server Utilities"},{"location":"complementary-tools/#graphql-clients","text":"GraphiQL \u2013 Graphical interactive in-browser GraphQL IDE GraphQL Playground \u2013 GraphQL IDE for better development workflows (GraphQL Subscriptions, interactive docs & collaboration) Altair GraphQL Client - Beautiful feature-rich GraphQL Client for all platforms Sailor - Typesafe GraphQL client for PHP","title":"GraphQL Clients"},{"location":"concepts/","text":"Overview \u00b6 GraphQL is data-centric. On the very top level it is built around three major concepts: Schema , Query and Mutation . You are expected to express your application as a Schema (aka Type System) and expose it as a single HTTP endpoint (e.g. using our standard server ). Application clients (e.g. web or mobile clients) send Queries to this endpoint to request structured data and Mutations to perform changes (usually with HTTP POST method). Queries \u00b6 Queries are expressed in simple language that resembles JSON: { hero { name friends { name } } } It was designed to mirror the structure of the expected response: { \"hero\": { \"name\": \"R2-D2\", \"friends\": [ { \"name\": \"Luke Skywalker\" }, { \"name\": \"Han Solo\" }, { \"name\": \"Leia Organa\" } ] } } The graphql-php runtime parses Queries, makes sure that they are valid for a given Type System and executes using data fetching tools provided by you as part of the integration. Queries are supposed to be idempotent. Mutations \u00b6 Mutations are root fields that are allowed to have side effects, such as creating, updating or deleting data. In contrast to Query fields, the fields within the root Mutation type are executed serially. Otherwise, their definition and execution is identical to all other fields. mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) { createReview(episode: $ep, review: $review) { stars commentary } } Variables $ep and $review are sent alongside with the mutation. A full HTTP request might look like this: // POST /graphql-endpoint // Content-Type: application/javascript // { \"query\": \"mutation CreateReviewForEpisode...\", \"variables\": { \"ep\": \"JEDI\", \"review\": { \"stars\": 5, \"commentary\": \"This is a great movie!\" } } } As you see variables may include complex objects and they will be correctly validated by the graphql-php runtime. Another nice feature of GraphQL mutations is that they also hold the query for data to be returned after mutation. In our example the mutation will return: { \"createReview\": { \"stars\": 5, \"commentary\": \"This is a great movie!\" } } Type System \u00b6 Conceptually a GraphQL type is a collection of fields. Each field in turn has its own type which allows building complex hierarchies. Quick example on pseudo-language: type BlogPost { title: String! author: User body: String } type User { id: Id! firstName: String lastName: String } The type system is at the heart of GraphQL integration. That's where graphql-php comes into play. It provides the following tools and primitives to describe your App as a hierarchy of types: Primitives for defining objects and interfaces Primitives for defining enumerations and unions Primitives for defining custom scalar types Built-in scalar types: ID , String , Int , Float , Boolean Built-in type modifiers: ListOf and NonNull Same example expressed in graphql-php : use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $userType = new ObjectType([ 'name' => 'User', 'fields' => [ 'id' => Type::nonNull(Type::id()), 'firstName' => Type::string(), 'lastName' => Type::string() ] ]); $blogPostType = new ObjectType([ 'name' => 'BlogPost', 'fields' => [ 'title' => Type::nonNull(Type::string()), 'author' => $userType ] ]); Further Reading \u00b6 To get deeper understanding of GraphQL concepts - read the docs on official GraphQL website To get started with graphql-php - continue to next section \"Getting Started\"","title":"Concepts"},{"location":"concepts/#overview","text":"GraphQL is data-centric. On the very top level it is built around three major concepts: Schema , Query and Mutation . You are expected to express your application as a Schema (aka Type System) and expose it as a single HTTP endpoint (e.g. using our standard server ). Application clients (e.g. web or mobile clients) send Queries to this endpoint to request structured data and Mutations to perform changes (usually with HTTP POST method).","title":"Overview"},{"location":"concepts/#queries","text":"Queries are expressed in simple language that resembles JSON: { hero { name friends { name } } } It was designed to mirror the structure of the expected response: { \"hero\": { \"name\": \"R2-D2\", \"friends\": [ { \"name\": \"Luke Skywalker\" }, { \"name\": \"Han Solo\" }, { \"name\": \"Leia Organa\" } ] } } The graphql-php runtime parses Queries, makes sure that they are valid for a given Type System and executes using data fetching tools provided by you as part of the integration. Queries are supposed to be idempotent.","title":"Queries"},{"location":"concepts/#mutations","text":"Mutations are root fields that are allowed to have side effects, such as creating, updating or deleting data. In contrast to Query fields, the fields within the root Mutation type are executed serially. Otherwise, their definition and execution is identical to all other fields. mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) { createReview(episode: $ep, review: $review) { stars commentary } } Variables $ep and $review are sent alongside with the mutation. A full HTTP request might look like this: // POST /graphql-endpoint // Content-Type: application/javascript // { \"query\": \"mutation CreateReviewForEpisode...\", \"variables\": { \"ep\": \"JEDI\", \"review\": { \"stars\": 5, \"commentary\": \"This is a great movie!\" } } } As you see variables may include complex objects and they will be correctly validated by the graphql-php runtime. Another nice feature of GraphQL mutations is that they also hold the query for data to be returned after mutation. In our example the mutation will return: { \"createReview\": { \"stars\": 5, \"commentary\": \"This is a great movie!\" } }","title":"Mutations"},{"location":"concepts/#type-system","text":"Conceptually a GraphQL type is a collection of fields. Each field in turn has its own type which allows building complex hierarchies. Quick example on pseudo-language: type BlogPost { title: String! author: User body: String } type User { id: Id! firstName: String lastName: String } The type system is at the heart of GraphQL integration. That's where graphql-php comes into play. It provides the following tools and primitives to describe your App as a hierarchy of types: Primitives for defining objects and interfaces Primitives for defining enumerations and unions Primitives for defining custom scalar types Built-in scalar types: ID , String , Int , Float , Boolean Built-in type modifiers: ListOf and NonNull Same example expressed in graphql-php : use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $userType = new ObjectType([ 'name' => 'User', 'fields' => [ 'id' => Type::nonNull(Type::id()), 'firstName' => Type::string(), 'lastName' => Type::string() ] ]); $blogPostType = new ObjectType([ 'name' => 'BlogPost', 'fields' => [ 'title' => Type::nonNull(Type::string()), 'author' => $userType ] ]);","title":"Type System"},{"location":"concepts/#further-reading","text":"To get deeper understanding of GraphQL concepts - read the docs on official GraphQL website To get started with graphql-php - continue to next section \"Getting Started\"","title":"Further Reading"},{"location":"data-fetching/","text":"Overview \u00b6 GraphQL is data-storage agnostic. You can use any underlying data storage engine, including but not limited to SQL or NoSQL databases, plain files or in-memory data structures. In order to convert the GraphQL query to a PHP array, graphql-php traverses query fields (using depth-first algorithm) and runs the special resolve function on each field. This resolve function is provided by you as a part of the field definition or query execution call . The result returned by the resolve function is directly included in the response (for scalars and enums) or passed down to nested fields (for objects). Let's walk through an example. Consider the following GraphQL query: { lastStory { title author { name } } } We need a Schema that can fulfill it. On the very top level, the Schema contains the Query type: use GraphQL\\Type\\Definition\\ObjectType; $queryType = new ObjectType([ 'name' => 'Query', 'fields' => [ 'lastStory' => [ 'type' => $blogStoryType, 'resolve' => fn (): array => [ 'id' => 1, 'title' => 'Example blog post', 'authorId' => 1 ], ] ] ]); As we see, the field lastStory has a resolve function that is responsible for fetching data. In our example, we simply return a static value, but in the real-world application you would query your data source and return the result from there. Since lastStory is of composite type BlogStory , this result is passed down to fields of this type: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; const USERS = [ 1 => [ 'id' => 1, 'name' => 'Smith' ], 2 => [ 'id' => 2, 'name' => 'Anderson' ] ]; $blogStoryType = new ObjectType([ 'name' => 'BlogStory', 'fields' => [ 'author' => [ 'type' => $userType, 'resolve' => fn (array $blogStory): array => USERS[$blogStory['authorId']], ], 'title' => [ 'type' => Type::string() ] ] ]); Here $blogStory is the array returned by the lastStory field above. Again: in real-world applications you would fetch user data from your data source by authorId and return it. Also, note that you don't have to return arrays. You can return any value, graphql-php will pass it untouched to nested resolvers. But then the question appears - the field title has no resolve option, how is it resolved? When you define no custom resolver, the default field resolver applies. Default Field Resolver \u00b6 graphql-php provides the following default field resolver: use GraphQL\\Type\\Definition\\ResolveInfo; function defaultFieldResolver($objectValue, array $args, $context, ResolveInfo $info) { $fieldName = $info->fieldName; $property = null; if (is_array($objectValue) || $objectValue instanceof ArrayAccess) { if (isset($objectValue[$fieldName])) { $property = $objectValue[$fieldName]; } } elseif (is_object($objectValue)) { if (isset($objectValue->{$fieldName})) { $property = $objectValue->{$fieldName}; } } return $property instanceof Closure ? $property($objectValue, $args, $contextValue, $info) : $property; } It returns value by key (for arrays) or property (for objects). If the value is not set, it returns null . To override the default resolver, pass it as an argument to executeQuery . Default Field Resolver per Type \u00b6 Sometimes it might be convenient to set default field resolver per type. You can do so by providing resolveField option in type config . For example: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\ResolveInfo; $userType = new ObjectType([ 'name' => 'User', 'fields' => [ 'name' => Type::string(), 'email' => Type::string() ], 'resolveField' => function (User $user, array $args, $context, ResolveInfo $info) { switch ($info->fieldName) { case 'name': return $user->getName(); case 'email': return $user->getEmail(); default: return null; } }, ]); Keep in mind that field resolver has precedence over default field resolver per type which in turn has precedence over default field resolver . Optimize Resolvers \u00b6 The 4th argument of resolver functions is an instance of ResolveInfo . It contains information that is useful for the field resolution process. Depending on which data source is used, knowing which fields the client queried can be used to optimize the performance of a resolver. For example, an SQL query may only need to select the queried fields. The following example limits which columns are selected from the database: use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\ResolveInfo; $queryType = new ObjectType([ 'name' => 'Query', 'fields' => [ 'lastStory' => [ 'type' => $storyType, 'resolve' => function ($root, array $args, $context, ResolveInfo $resolveInfo): Story { // Fictitious API, use whatever database access your application/framework provides $builder = Story::builder(); foreach ($resolveInfo->getFieldSelection() as $field => $_) { $builder->addSelect($field); } return $builder->last(); } ] ] ]); Solving N+1 Problem \u00b6 Since: 0.9.0 One of the most annoying problems with data fetching is a so-called N+1 problem . Consider following GraphQL query: { topStories(limit: 10) { title author { name email } } } Naive field resolution process would require up to 10 calls to the underlying data store to fetch authors for all 10 stories. graphql-php provides tools to mitigate this problem: it allows you to defer actual field resolution to a later stage when one batched query could be executed instead of 10 distinct queries. Here is an example of BlogStory resolver for field author that uses deferring: use GraphQL\\Deferred; 'resolve' => function (array $blogStory): Deferred { MyUserBuffer::add($blogStory['authorId']); return new Deferred(function () use ($blogStory): User { MyUserBuffer::loadBuffered(); return MyUserBuffer::get($blogStory['authorId']); }); } In this example, we fill up the buffer with 10 author ids first. Then graphql-php continues resolving other non-deferred fields until there are none of them left. After that, it calls closures wrapped by GraphQL\\Deferred which in turn load all buffered ids once (using SQL IN(?) , Redis MGET or similar tools) and returns the final field value. Originally this approach was advocated by Facebook in their Dataloader project. This solution enables very interesting optimizations at no cost. Consider the following query: { topStories(limit: 10) { author { email } } category { stories(limit: 10) { author { email } } } } Even though author field is located on different levels of the query - it can be buffered in the same buffer. In this example, only one query will be executed for all story authors comparing to 20 queries in a naive implementation. Async PHP \u00b6 Since: 0.10.0 (version 0.9.0 had slightly different API which still works, but is deprecated) If your project runs in an environment that supports async operations (like HHVM, ReactPHP, Icicle.io, appserver.io, PHP threads, etc) you can leverage the power of your platform to resolve some fields asynchronously. The only requirement: your platform must support the concept of Promises compatible with Promises A+ specification. To start using this feature, switch facade method for query execution from executeQuery to promiseToExecute : use GraphQL\\GraphQL; use GraphQL\\Executor\\ExecutionResult; $promise = GraphQL::promiseToExecute( $promiseAdapter, $schema, $queryString, $rootValue = null, $contextValue = null, $variableValues = null, $operationName = null, $fieldResolver = null, $validationRules = null ); $promise->then(fn (ExecutionResult $result): array => $result->toArray()); Where $promiseAdapter is an instance of: For ReactPHP (requires react/promise as composer dependency): GraphQL\\Executor\\Promise\\Adapter\\ReactPromiseAdapter Other platforms: write your own class implementing interface: GraphQL\\Executor\\Promise\\PromiseAdapter . Then your resolve functions should return promises of your platform instead of GraphQL\\Deferred s.","title":"Fetching Data"},{"location":"data-fetching/#overview","text":"GraphQL is data-storage agnostic. You can use any underlying data storage engine, including but not limited to SQL or NoSQL databases, plain files or in-memory data structures. In order to convert the GraphQL query to a PHP array, graphql-php traverses query fields (using depth-first algorithm) and runs the special resolve function on each field. This resolve function is provided by you as a part of the field definition or query execution call . The result returned by the resolve function is directly included in the response (for scalars and enums) or passed down to nested fields (for objects). Let's walk through an example. Consider the following GraphQL query: { lastStory { title author { name } } } We need a Schema that can fulfill it. On the very top level, the Schema contains the Query type: use GraphQL\\Type\\Definition\\ObjectType; $queryType = new ObjectType([ 'name' => 'Query', 'fields' => [ 'lastStory' => [ 'type' => $blogStoryType, 'resolve' => fn (): array => [ 'id' => 1, 'title' => 'Example blog post', 'authorId' => 1 ], ] ] ]); As we see, the field lastStory has a resolve function that is responsible for fetching data. In our example, we simply return a static value, but in the real-world application you would query your data source and return the result from there. Since lastStory is of composite type BlogStory , this result is passed down to fields of this type: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; const USERS = [ 1 => [ 'id' => 1, 'name' => 'Smith' ], 2 => [ 'id' => 2, 'name' => 'Anderson' ] ]; $blogStoryType = new ObjectType([ 'name' => 'BlogStory', 'fields' => [ 'author' => [ 'type' => $userType, 'resolve' => fn (array $blogStory): array => USERS[$blogStory['authorId']], ], 'title' => [ 'type' => Type::string() ] ] ]); Here $blogStory is the array returned by the lastStory field above. Again: in real-world applications you would fetch user data from your data source by authorId and return it. Also, note that you don't have to return arrays. You can return any value, graphql-php will pass it untouched to nested resolvers. But then the question appears - the field title has no resolve option, how is it resolved? When you define no custom resolver, the default field resolver applies.","title":"Overview"},{"location":"data-fetching/#default-field-resolver","text":"graphql-php provides the following default field resolver: use GraphQL\\Type\\Definition\\ResolveInfo; function defaultFieldResolver($objectValue, array $args, $context, ResolveInfo $info) { $fieldName = $info->fieldName; $property = null; if (is_array($objectValue) || $objectValue instanceof ArrayAccess) { if (isset($objectValue[$fieldName])) { $property = $objectValue[$fieldName]; } } elseif (is_object($objectValue)) { if (isset($objectValue->{$fieldName})) { $property = $objectValue->{$fieldName}; } } return $property instanceof Closure ? $property($objectValue, $args, $contextValue, $info) : $property; } It returns value by key (for arrays) or property (for objects). If the value is not set, it returns null . To override the default resolver, pass it as an argument to executeQuery .","title":"Default Field Resolver"},{"location":"data-fetching/#default-field-resolver-per-type","text":"Sometimes it might be convenient to set default field resolver per type. You can do so by providing resolveField option in type config . For example: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\ResolveInfo; $userType = new ObjectType([ 'name' => 'User', 'fields' => [ 'name' => Type::string(), 'email' => Type::string() ], 'resolveField' => function (User $user, array $args, $context, ResolveInfo $info) { switch ($info->fieldName) { case 'name': return $user->getName(); case 'email': return $user->getEmail(); default: return null; } }, ]); Keep in mind that field resolver has precedence over default field resolver per type which in turn has precedence over default field resolver .","title":"Default Field Resolver per Type"},{"location":"data-fetching/#optimize-resolvers","text":"The 4th argument of resolver functions is an instance of ResolveInfo . It contains information that is useful for the field resolution process. Depending on which data source is used, knowing which fields the client queried can be used to optimize the performance of a resolver. For example, an SQL query may only need to select the queried fields. The following example limits which columns are selected from the database: use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\ResolveInfo; $queryType = new ObjectType([ 'name' => 'Query', 'fields' => [ 'lastStory' => [ 'type' => $storyType, 'resolve' => function ($root, array $args, $context, ResolveInfo $resolveInfo): Story { // Fictitious API, use whatever database access your application/framework provides $builder = Story::builder(); foreach ($resolveInfo->getFieldSelection() as $field => $_) { $builder->addSelect($field); } return $builder->last(); } ] ] ]);","title":"Optimize Resolvers"},{"location":"data-fetching/#solving-n1-problem","text":"Since: 0.9.0 One of the most annoying problems with data fetching is a so-called N+1 problem . Consider following GraphQL query: { topStories(limit: 10) { title author { name email } } } Naive field resolution process would require up to 10 calls to the underlying data store to fetch authors for all 10 stories. graphql-php provides tools to mitigate this problem: it allows you to defer actual field resolution to a later stage when one batched query could be executed instead of 10 distinct queries. Here is an example of BlogStory resolver for field author that uses deferring: use GraphQL\\Deferred; 'resolve' => function (array $blogStory): Deferred { MyUserBuffer::add($blogStory['authorId']); return new Deferred(function () use ($blogStory): User { MyUserBuffer::loadBuffered(); return MyUserBuffer::get($blogStory['authorId']); }); } In this example, we fill up the buffer with 10 author ids first. Then graphql-php continues resolving other non-deferred fields until there are none of them left. After that, it calls closures wrapped by GraphQL\\Deferred which in turn load all buffered ids once (using SQL IN(?) , Redis MGET or similar tools) and returns the final field value. Originally this approach was advocated by Facebook in their Dataloader project. This solution enables very interesting optimizations at no cost. Consider the following query: { topStories(limit: 10) { author { email } } category { stories(limit: 10) { author { email } } } } Even though author field is located on different levels of the query - it can be buffered in the same buffer. In this example, only one query will be executed for all story authors comparing to 20 queries in a naive implementation.","title":"Solving N+1 Problem"},{"location":"data-fetching/#async-php","text":"Since: 0.10.0 (version 0.9.0 had slightly different API which still works, but is deprecated) If your project runs in an environment that supports async operations (like HHVM, ReactPHP, Icicle.io, appserver.io, PHP threads, etc) you can leverage the power of your platform to resolve some fields asynchronously. The only requirement: your platform must support the concept of Promises compatible with Promises A+ specification. To start using this feature, switch facade method for query execution from executeQuery to promiseToExecute : use GraphQL\\GraphQL; use GraphQL\\Executor\\ExecutionResult; $promise = GraphQL::promiseToExecute( $promiseAdapter, $schema, $queryString, $rootValue = null, $contextValue = null, $variableValues = null, $operationName = null, $fieldResolver = null, $validationRules = null ); $promise->then(fn (ExecutionResult $result): array => $result->toArray()); Where $promiseAdapter is an instance of: For ReactPHP (requires react/promise as composer dependency): GraphQL\\Executor\\Promise\\Adapter\\ReactPromiseAdapter Other platforms: write your own class implementing interface: GraphQL\\Executor\\Promise\\PromiseAdapter . Then your resolve functions should return promises of your platform instead of GraphQL\\Deferred s.","title":"Async PHP"},{"location":"error-handling/","text":"Errors in GraphQL \u00b6 There are 3 types of errors in GraphQL: Syntax : query has invalid syntax and could not be parsed; Validation : query is incompatible with type system (e.g. unknown field is requested); Execution : occurs when some field resolver throws (or returns unexpected value). When Syntax or Validation errors are detected, an exception is thrown and the query is not executed. Exceptions thrown during query execution are caught and collected in the result. They are available in $errors prop of GraphQL\\Executor\\ExecutionResult . GraphQL is forgiving to Execution errors which occur in resolvers of nullable fields. If such field throws or returns unexpected value the value of the field in response will be simply replaced with null and error entry will be registered. If an exception is thrown in the non-null field - error bubbles up to the first nullable field. This nullable field is replaced with null and error entry is added to the result. If all fields up to the root are non-null - data entry will be removed from the result and only errors key will be presented. When the result is converted to a serializable array using its toArray() method, all errors are converted to arrays as well using default error formatting (see below). Alternatively, you can apply custom error filtering and formatting for your specific requirements. Default Error formatting \u00b6 By default, each error entry is converted to an associative array with following structure: [ 'message' => 'Error message', 'extensions' => [ 'key' => 'value', ], 'locations' => [ ['line' => 1, 'column' => 2], ], 'path' => [ 'listField', 0, 'fieldWithException', ], ]; Entry at key locations points to a character in query string which caused the error. In some cases (like deep fragment fields) locations will include several entries to track down the path to field with the error in query. Entry at key path exists only for errors caused by exceptions thrown in resolvers. It contains a path from the very root field to actual field value producing an error (including indexes for list types and field names for composite types). Internal errors \u00b6 As of version 0.10.0 , all exceptions thrown in resolvers are reported with generic message \"Internal server error\" . This is done to avoid information leak in production environments (e.g. database connection errors, file access errors, etc). Only exceptions implementing interface GraphQL\\Error\\ClientAware and claiming themselves as safe will be reported with a full error message. For example: use GraphQL\\Error\\ClientAware; class MySafeException extends \\Exception implements ClientAware { public function isClientSafe(): bool { return true; } } When such exception is thrown it will be reported with a full error message: [ 'message' => 'My reported error', 'locations' => [ ['line' => 10, 'column' => 2], ], 'path' => [ 'path', 'to', 'fieldWithException', ] ]; To change default \"Internal server error\" message to something else, use: GraphQL\\Error\\FormattedError::setInternalErrorMessage(\"Unexpected error\"); Debugging tools \u00b6 During development or debugging use $result->toArray(DebugFlag::INCLUDE_DEBUG_MESSAGE) to add debugMessage key to each formatted error entry. If you also want to add exception trace - pass flags instead: use GraphQL\\Error\\DebugFlag; $debug = DebugFlag::INCLUDE_DEBUG_MESSAGE | DebugFlag::INCLUDE_TRACE; $result = GraphQL::executeQuery(/*args*/)->toArray($debug); This will make each error entry to look like this: [ 'message' => 'Internal server error', 'locations' => [ ['line' => 10, 'column' => 2], ], 'path' => [ 'listField', 0, 'fieldWithException', ], 'extensions' => [ 'debugMessage' => 'Actual exception message', 'trace' => [ /* Formatted original exception trace */ ], ] ]; If you prefer the first resolver exception to be re-thrown, use following flags: use GraphQL\\GraphQL; use GraphQL\\Error\\DebugFlag; $debug = DebugFlag::INCLUDE_DEBUG_MESSAGE | DebugFlag::RETHROW_INTERNAL_EXCEPTIONS; // Following will throw if there was an exception in resolver during execution: $result = GraphQL::executeQuery(/*args*/)->toArray($debug); If you only want to re-throw Exceptions that are not marked as safe through the ClientAware interface, use the flag Debug::RETHROW_UNSAFE_EXCEPTIONS . Custom Error Handling and Formatting \u00b6 It is possible to define custom formatter and handler for result errors. Formatter is responsible for converting instances of GraphQL\\Error\\Error to an array. Handler is useful for error filtering and logging. For example, these are default formatter and handler: use GraphQL\\GraphQL; use GraphQL\\Error\\Error; use GraphQL\\Error\\FormattedError; $result = GraphQL::executeQuery(/* $args */) ->setErrorFormatter(fn (Error $error): array => FormattedError::createFromException($error)) ->setErrorsHandler(fn (array $errors, callable $formatter): array => array_map($formatter, $errors)) ->toArray(); Note that when you pass debug flags to toArray() your custom formatter will still be decorated with same debugging information mentioned above. Schema Errors \u00b6 So far we only covered errors which occur during query execution process. Schema definition can also throw GraphQL\\Error\\InvariantViolation if there is an error in one of type definitions. Usually such errors mean that there is some logical error in your schema. In this case it makes sense to return a status code 500 (Internal Server Error) for GraphQL endpoint: use GraphQL\\GraphQL; use GraphQL\\Type\\Schema; use GraphQL\\Error\\FormattedError; try { $schema = new Schema([ // ... ]); $body = GraphQL::executeQuery($schema, $query); $status = 200; } catch(\\Exception $e) { $body = [ 'errors' => [FormattedError::createFromException($e)] ]; $status = 500; } header('Content-Type: application/json', true, $status); echo json_encode($body);","title":"Handling Errors"},{"location":"error-handling/#errors-in-graphql","text":"There are 3 types of errors in GraphQL: Syntax : query has invalid syntax and could not be parsed; Validation : query is incompatible with type system (e.g. unknown field is requested); Execution : occurs when some field resolver throws (or returns unexpected value). When Syntax or Validation errors are detected, an exception is thrown and the query is not executed. Exceptions thrown during query execution are caught and collected in the result. They are available in $errors prop of GraphQL\\Executor\\ExecutionResult . GraphQL is forgiving to Execution errors which occur in resolvers of nullable fields. If such field throws or returns unexpected value the value of the field in response will be simply replaced with null and error entry will be registered. If an exception is thrown in the non-null field - error bubbles up to the first nullable field. This nullable field is replaced with null and error entry is added to the result. If all fields up to the root are non-null - data entry will be removed from the result and only errors key will be presented. When the result is converted to a serializable array using its toArray() method, all errors are converted to arrays as well using default error formatting (see below). Alternatively, you can apply custom error filtering and formatting for your specific requirements.","title":"Errors in GraphQL"},{"location":"error-handling/#default-error-formatting","text":"By default, each error entry is converted to an associative array with following structure: [ 'message' => 'Error message', 'extensions' => [ 'key' => 'value', ], 'locations' => [ ['line' => 1, 'column' => 2], ], 'path' => [ 'listField', 0, 'fieldWithException', ], ]; Entry at key locations points to a character in query string which caused the error. In some cases (like deep fragment fields) locations will include several entries to track down the path to field with the error in query. Entry at key path exists only for errors caused by exceptions thrown in resolvers. It contains a path from the very root field to actual field value producing an error (including indexes for list types and field names for composite types).","title":"Default Error formatting"},{"location":"error-handling/#internal-errors","text":"As of version 0.10.0 , all exceptions thrown in resolvers are reported with generic message \"Internal server error\" . This is done to avoid information leak in production environments (e.g. database connection errors, file access errors, etc). Only exceptions implementing interface GraphQL\\Error\\ClientAware and claiming themselves as safe will be reported with a full error message. For example: use GraphQL\\Error\\ClientAware; class MySafeException extends \\Exception implements ClientAware { public function isClientSafe(): bool { return true; } } When such exception is thrown it will be reported with a full error message: [ 'message' => 'My reported error', 'locations' => [ ['line' => 10, 'column' => 2], ], 'path' => [ 'path', 'to', 'fieldWithException', ] ]; To change default \"Internal server error\" message to something else, use: GraphQL\\Error\\FormattedError::setInternalErrorMessage(\"Unexpected error\");","title":"Internal errors"},{"location":"error-handling/#debugging-tools","text":"During development or debugging use $result->toArray(DebugFlag::INCLUDE_DEBUG_MESSAGE) to add debugMessage key to each formatted error entry. If you also want to add exception trace - pass flags instead: use GraphQL\\Error\\DebugFlag; $debug = DebugFlag::INCLUDE_DEBUG_MESSAGE | DebugFlag::INCLUDE_TRACE; $result = GraphQL::executeQuery(/*args*/)->toArray($debug); This will make each error entry to look like this: [ 'message' => 'Internal server error', 'locations' => [ ['line' => 10, 'column' => 2], ], 'path' => [ 'listField', 0, 'fieldWithException', ], 'extensions' => [ 'debugMessage' => 'Actual exception message', 'trace' => [ /* Formatted original exception trace */ ], ] ]; If you prefer the first resolver exception to be re-thrown, use following flags: use GraphQL\\GraphQL; use GraphQL\\Error\\DebugFlag; $debug = DebugFlag::INCLUDE_DEBUG_MESSAGE | DebugFlag::RETHROW_INTERNAL_EXCEPTIONS; // Following will throw if there was an exception in resolver during execution: $result = GraphQL::executeQuery(/*args*/)->toArray($debug); If you only want to re-throw Exceptions that are not marked as safe through the ClientAware interface, use the flag Debug::RETHROW_UNSAFE_EXCEPTIONS .","title":"Debugging tools"},{"location":"error-handling/#custom-error-handling-and-formatting","text":"It is possible to define custom formatter and handler for result errors. Formatter is responsible for converting instances of GraphQL\\Error\\Error to an array. Handler is useful for error filtering and logging. For example, these are default formatter and handler: use GraphQL\\GraphQL; use GraphQL\\Error\\Error; use GraphQL\\Error\\FormattedError; $result = GraphQL::executeQuery(/* $args */) ->setErrorFormatter(fn (Error $error): array => FormattedError::createFromException($error)) ->setErrorsHandler(fn (array $errors, callable $formatter): array => array_map($formatter, $errors)) ->toArray(); Note that when you pass debug flags to toArray() your custom formatter will still be decorated with same debugging information mentioned above.","title":"Custom Error Handling and Formatting"},{"location":"error-handling/#schema-errors","text":"So far we only covered errors which occur during query execution process. Schema definition can also throw GraphQL\\Error\\InvariantViolation if there is an error in one of type definitions. Usually such errors mean that there is some logical error in your schema. In this case it makes sense to return a status code 500 (Internal Server Error) for GraphQL endpoint: use GraphQL\\GraphQL; use GraphQL\\Type\\Schema; use GraphQL\\Error\\FormattedError; try { $schema = new Schema([ // ... ]); $body = GraphQL::executeQuery($schema, $query); $status = 200; } catch(\\Exception $e) { $body = [ 'errors' => [FormattedError::createFromException($e)] ]; $status = 500; } header('Content-Type: application/json', true, $status); echo json_encode($body);","title":"Schema Errors"},{"location":"executing-queries/","text":"Using Facade Method \u00b6 Query execution is a complex process involving multiple steps, including query parsing , validating and finally executing against your schema . graphql-php provides a convenient facade for this process in class GraphQL\\GraphQL : use GraphQL\\GraphQL; $result = GraphQL::executeQuery( $schema, $queryString, $rootValue = null, $context = null, $variableValues = null, $operationName = null, $fieldResolver = null, $validationRules = null ); It returns an instance of GraphQL\\Executor\\ExecutionResult which can be easily converted to array: $serializableResult = $result->toArray(); Returned array contains data and errors keys, as described by the GraphQL spec . This array is suitable for further serialization (e.g. using json_encode ). See also the section on error handling and formatting . Method arguments \u00b6 Description of executeQuery method arguments: Argument Type Notes schema GraphQL\\Type\\Schema Required. Instance of your application Schema queryString string or GraphQL\\Language\\AST\\DocumentNode Required. Actual GraphQL query string to be parsed, validated and executed. If you parse query elsewhere before executing - pass corresponding AST document here to avoid new parsing. rootValue mixed Any value that represents a root of your data graph. It is passed as the 1st argument to field resolvers of Query type . Can be omitted or set to null if actual root values are fetched by Query type itself. context mixed Any value that holds information shared between all field resolvers. Most often they use it to pass currently logged in user, locale details, etc. It will be available as the 3rd argument in all field resolvers. (see section on Field Definitions for reference) graphql-php never modifies this value and passes it as is to all underlying resolvers. variableValues array Map of variable values passed along with query string. See section on query variables on official GraphQL website . Note that while variableValues must be an associative array, the values inside it can be nested using \\stdClass if desired. operationName string Allows the caller to specify which operation in queryString will be run, in cases where queryString contains multiple top-level operations. fieldResolver callable A resolver function to use when one is not provided by the schema. If not provided, the default field resolver is used . validationRules array A set of rules for query validation step. The default value is all available rules. Empty array would allow skipping query validation (may be convenient for persisted queries which are validated before persisting and assumed valid during execution) Using Server \u00b6 If you are building HTTP GraphQL API, you may prefer our Standard Server (compatible with express-graphql ). It supports more features out of the box, including parsing HTTP requests, producing a spec-compliant response; batched queries ; persisted queries. Usage example (with plain PHP): use GraphQL\\Server\\StandardServer; $server = new StandardServer([/* server options, see below */]); $server->handleRequest(); // parses PHP globals and emits response Server also supports PSR-7 request/response interfaces : use GraphQL\\Server\\StandardServer; use GraphQL\\Executor\\ExecutionResult; use Psr\\Http\\Message\\RequestInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\StreamInterface; /** @var RequestInterface $psrRequest */ /** @var ResponseInterface $psrResponse */ /** @var StreamInterface $psrBodyStream */ $server = new StandardServer([/* server options, see below */]); $psrResponse = $server->processPsrRequest($psrRequest, $psrResponse, $psrBodyStream); // Alternatively create PSR-7 response yourself: /** @var ExecutionResult|ExecutionResult[] $result */ $result = $server->executePsrRequest($psrRequest); $psrResponse = new SomePsr7ResponseImplementation(json_encode($result)); PSR-7 is useful when you want to integrate the server into existing framework: PSR-7 for Laravel Symfony PSR-7 Bridge Slim Laminas Mezzio Server configuration options \u00b6 Argument Type Notes schema Schema Required. Instance of your application Schema rootValue mixed Any value that represents a root of your data graph. It is passed as the 1st argument to field resolvers of Query type . Can be omitted or set to null if actual root values are fetched by Query type itself. context mixed Any value that holds information shared between all field resolvers. Most often they use it to pass currently logged in user, locale details, etc. It will be available as the 3rd argument in all field resolvers. (see section on Field Definitions for reference) graphql-php never modifies this value and passes it as is to all underlying resolvers. fieldResolver callable A resolver function to use when one is not provided by the schema. If not provided, the default field resolver is used . validationRules array or callable A set of rules for query validation step. The default value is all available rules. The empty array would allow skipping query validation (may be convenient for persisted queries which are validated before persisting and assumed valid during execution). Pass callable to return different validation rules for different queries (e.g. empty array for persisted query and a full list of rules for regular queries). When passed, it is expected to have the following signature: function ( OperationParams $params, DocumentNode $node, $operationType): array queryBatching bool Flag indicating whether this server supports query batching ( apollo-style ). Defaults to false debugFlag int Debug flags. See docs on error debugging (flag values are the same). persistedQueryLoader callable A function which is called to fetch actual query when server encounters a queryId without a query . The server does not implement persistence part (which you will have to build on your own), but it allows you to execute queries which were persisted previously. Expected function signature: function ($queryId, OperationParams $params) Function is expected to return query string or parsed DocumentNode Read more about persisted queries . errorFormatter callable Custom error formatter. See error handling docs . errorsHandler callable Custom errors handler. See error handling docs . promiseAdapter PromiseAdapter Required for Async PHP only. Using config class \u00b6 If you prefer fluid interface for config with autocomplete in IDE and static time validation, use GraphQL\\Server\\ServerConfig instead of an array: use GraphQL\\Server\\ServerConfig; use GraphQL\\Server\\StandardServer; $config = ServerConfig::create() ->setSchema($schema) ->setErrorFormatter($myFormatter) ->setDebugFlag($debug) ; $server = new StandardServer($config); Query batching \u00b6 Standard Server supports query batching ( apollo-style ). One of the major benefits of Server over a sequence of executeQuery() calls is that Deferred resolvers won't be isolated in queries. So for example following batch will require single DB request (if user field is deferred): [ { \"query\": \"{user(id: 1) { id }}\" }, { \"query\": \"{user(id: 2) { id }}\" }, { \"query\": \"{user(id: 3) { id }}\" } ] To enable query batching, pass queryBatching option in server config: use GraphQL\\Server\\StandardServer; $server = new StandardServer([ 'queryBatching' => true ]); Custom Validation Rules \u00b6 Before execution, a query is validated using a set of standard rules defined by the GraphQL spec. It is possible to override standard set of rules globally or per execution. Add rules globally: use GraphQL\\Validator\\Rules; use GraphQL\\Validator\\DocumentValidator; // Add to standard set of rules globally: DocumentValidator::addRule(new Rules\\DisableIntrospection()); Custom rules per execution: use GraphQL\\GraphQL; use GraphQL\\Validator\\Rules; $myValidationRules = array_merge( GraphQL::getStandardValidationRules(), [ new Rules\\QueryComplexity(100), new Rules\\DisableIntrospection() ] ); $result = GraphQL::executeQuery( $schema, $queryString, $rootValue = null, $context = null, $variableValues = null, $operationName = null, $fieldResolver = null, $myValidationRules // <-- this will override global validation rules for this request ); Or with a standard server: use GraphQL\\Server\\StandardServer; $server = new StandardServer([ 'validationRules' => $myValiationRules ]);","title":"Executing Queries"},{"location":"executing-queries/#using-facade-method","text":"Query execution is a complex process involving multiple steps, including query parsing , validating and finally executing against your schema . graphql-php provides a convenient facade for this process in class GraphQL\\GraphQL : use GraphQL\\GraphQL; $result = GraphQL::executeQuery( $schema, $queryString, $rootValue = null, $context = null, $variableValues = null, $operationName = null, $fieldResolver = null, $validationRules = null ); It returns an instance of GraphQL\\Executor\\ExecutionResult which can be easily converted to array: $serializableResult = $result->toArray(); Returned array contains data and errors keys, as described by the GraphQL spec . This array is suitable for further serialization (e.g. using json_encode ). See also the section on error handling and formatting .","title":"Using Facade Method"},{"location":"executing-queries/#method-arguments","text":"Description of executeQuery method arguments: Argument Type Notes schema GraphQL\\Type\\Schema Required. Instance of your application Schema queryString string or GraphQL\\Language\\AST\\DocumentNode Required. Actual GraphQL query string to be parsed, validated and executed. If you parse query elsewhere before executing - pass corresponding AST document here to avoid new parsing. rootValue mixed Any value that represents a root of your data graph. It is passed as the 1st argument to field resolvers of Query type . Can be omitted or set to null if actual root values are fetched by Query type itself. context mixed Any value that holds information shared between all field resolvers. Most often they use it to pass currently logged in user, locale details, etc. It will be available as the 3rd argument in all field resolvers. (see section on Field Definitions for reference) graphql-php never modifies this value and passes it as is to all underlying resolvers. variableValues array Map of variable values passed along with query string. See section on query variables on official GraphQL website . Note that while variableValues must be an associative array, the values inside it can be nested using \\stdClass if desired. operationName string Allows the caller to specify which operation in queryString will be run, in cases where queryString contains multiple top-level operations. fieldResolver callable A resolver function to use when one is not provided by the schema. If not provided, the default field resolver is used . validationRules array A set of rules for query validation step. The default value is all available rules. Empty array would allow skipping query validation (may be convenient for persisted queries which are validated before persisting and assumed valid during execution)","title":"Method arguments"},{"location":"executing-queries/#using-server","text":"If you are building HTTP GraphQL API, you may prefer our Standard Server (compatible with express-graphql ). It supports more features out of the box, including parsing HTTP requests, producing a spec-compliant response; batched queries ; persisted queries. Usage example (with plain PHP): use GraphQL\\Server\\StandardServer; $server = new StandardServer([/* server options, see below */]); $server->handleRequest(); // parses PHP globals and emits response Server also supports PSR-7 request/response interfaces : use GraphQL\\Server\\StandardServer; use GraphQL\\Executor\\ExecutionResult; use Psr\\Http\\Message\\RequestInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\StreamInterface; /** @var RequestInterface $psrRequest */ /** @var ResponseInterface $psrResponse */ /** @var StreamInterface $psrBodyStream */ $server = new StandardServer([/* server options, see below */]); $psrResponse = $server->processPsrRequest($psrRequest, $psrResponse, $psrBodyStream); // Alternatively create PSR-7 response yourself: /** @var ExecutionResult|ExecutionResult[] $result */ $result = $server->executePsrRequest($psrRequest); $psrResponse = new SomePsr7ResponseImplementation(json_encode($result)); PSR-7 is useful when you want to integrate the server into existing framework: PSR-7 for Laravel Symfony PSR-7 Bridge Slim Laminas Mezzio","title":"Using Server"},{"location":"executing-queries/#server-configuration-options","text":"Argument Type Notes schema Schema Required. Instance of your application Schema rootValue mixed Any value that represents a root of your data graph. It is passed as the 1st argument to field resolvers of Query type . Can be omitted or set to null if actual root values are fetched by Query type itself. context mixed Any value that holds information shared between all field resolvers. Most often they use it to pass currently logged in user, locale details, etc. It will be available as the 3rd argument in all field resolvers. (see section on Field Definitions for reference) graphql-php never modifies this value and passes it as is to all underlying resolvers. fieldResolver callable A resolver function to use when one is not provided by the schema. If not provided, the default field resolver is used . validationRules array or callable A set of rules for query validation step. The default value is all available rules. The empty array would allow skipping query validation (may be convenient for persisted queries which are validated before persisting and assumed valid during execution). Pass callable to return different validation rules for different queries (e.g. empty array for persisted query and a full list of rules for regular queries). When passed, it is expected to have the following signature: function ( OperationParams $params, DocumentNode $node, $operationType): array queryBatching bool Flag indicating whether this server supports query batching ( apollo-style ). Defaults to false debugFlag int Debug flags. See docs on error debugging (flag values are the same). persistedQueryLoader callable A function which is called to fetch actual query when server encounters a queryId without a query . The server does not implement persistence part (which you will have to build on your own), but it allows you to execute queries which were persisted previously. Expected function signature: function ($queryId, OperationParams $params) Function is expected to return query string or parsed DocumentNode Read more about persisted queries . errorFormatter callable Custom error formatter. See error handling docs . errorsHandler callable Custom errors handler. See error handling docs . promiseAdapter PromiseAdapter Required for Async PHP only.","title":"Server configuration options"},{"location":"executing-queries/#using-config-class","text":"If you prefer fluid interface for config with autocomplete in IDE and static time validation, use GraphQL\\Server\\ServerConfig instead of an array: use GraphQL\\Server\\ServerConfig; use GraphQL\\Server\\StandardServer; $config = ServerConfig::create() ->setSchema($schema) ->setErrorFormatter($myFormatter) ->setDebugFlag($debug) ; $server = new StandardServer($config);","title":"Using config class"},{"location":"executing-queries/#query-batching","text":"Standard Server supports query batching ( apollo-style ). One of the major benefits of Server over a sequence of executeQuery() calls is that Deferred resolvers won't be isolated in queries. So for example following batch will require single DB request (if user field is deferred): [ { \"query\": \"{user(id: 1) { id }}\" }, { \"query\": \"{user(id: 2) { id }}\" }, { \"query\": \"{user(id: 3) { id }}\" } ] To enable query batching, pass queryBatching option in server config: use GraphQL\\Server\\StandardServer; $server = new StandardServer([ 'queryBatching' => true ]);","title":"Query batching"},{"location":"executing-queries/#custom-validation-rules","text":"Before execution, a query is validated using a set of standard rules defined by the GraphQL spec. It is possible to override standard set of rules globally or per execution. Add rules globally: use GraphQL\\Validator\\Rules; use GraphQL\\Validator\\DocumentValidator; // Add to standard set of rules globally: DocumentValidator::addRule(new Rules\\DisableIntrospection()); Custom rules per execution: use GraphQL\\GraphQL; use GraphQL\\Validator\\Rules; $myValidationRules = array_merge( GraphQL::getStandardValidationRules(), [ new Rules\\QueryComplexity(100), new Rules\\DisableIntrospection() ] ); $result = GraphQL::executeQuery( $schema, $queryString, $rootValue = null, $context = null, $variableValues = null, $operationName = null, $fieldResolver = null, $myValidationRules // <-- this will override global validation rules for this request ); Or with a standard server: use GraphQL\\Server\\StandardServer; $server = new StandardServer([ 'validationRules' => $myValiationRules ]);","title":"Custom Validation Rules"},{"location":"getting-started/","text":"Prerequisites \u00b6 This documentation assumes your familiarity with GraphQL concepts. If it is not the case - first learn about GraphQL on the official website . Installation \u00b6 Using composer , run: composer require webonyx/graphql-php Upgrading \u00b6 We try to keep library releases backwards compatible when possible. For breaking changes we provide upgrade instructions . Install Tools (optional) \u00b6 While it is possible to communicate with GraphQL API using regular HTTP tools it is way more convenient for humans to use GraphiQL - an in-browser IDE for exploring GraphQL APIs. It provides syntax-highlighting, auto-completion and auto-generated documentation for GraphQL API. The easiest way to use it is to install one of the existing Google Chrome extensions: ChromeiQL GraphiQL Feen Alternatively, you can follow instructions on the GraphiQL page and install it locally. Hello World \u00b6 Let's create a type system that will be capable to process the following simple query: query { echo(message: \"Hello World\") } We need an object type with the field echo : use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\Type; $queryType = new ObjectType([ 'name' => 'Query', 'fields' => [ 'echo' => [ 'type' => Type::string(), 'args' => [ 'message' => Type::nonNull(Type::string()), ], 'resolve' => fn ($rootValue, array $args): string => $rootValue['prefix'] . $args['message'], ], ], ]); (Note: type definition can be expressed in different styles ) The interesting piece here is the resolve option of the field definition. It is responsible for returning a value of our field. Values of scalar fields will be directly included in the response while values of composite fields (objects, interfaces, unions) will be passed down to nested field resolvers (not in this example though). Now when our type is ready, let's create a GraphQL endpoint file for it graphql.php : use GraphQL\\GraphQL; use GraphQL\\Type\\Schema; $schema = new Schema([ 'query' => $queryType ]); $rawInput = file_get_contents('php://input'); $input = json_decode($rawInput, true); $query = $input['query']; $variableValues = isset($input['variables']) ? $input['variables'] : null; try { $rootValue = ['prefix' => 'You said: ']; $result = GraphQL::executeQuery($schema, $query, $rootValue, null, $variableValues); $output = $result->toArray(); } catch (\\Exception $e) { $output = [ 'errors' => [ [ 'message' => $e->getMessage() ] ] ]; } header('Content-Type: application/json'); echo json_encode($output); Our example is finished. Try it by running: php -S localhost:8080 graphql.php curl http://localhost:8080 -d '{\"query\": \"query { echo(message: \\\"Hello World\\\") }\" }' Check out the full source code of this example which also includes simple mutation. Check out the blog example for something which is closer to real-world apps or read about the details of schema definition . Next Steps \u00b6 Obviously hello world only scratches the surface of what is possible. To learn by example, check out the blog example which is quite close to real-world GraphQL hierarchies. For a deeper understanding of GraphQL in general, check out concepts . To delve right into the implementation, see schema definition .","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"This documentation assumes your familiarity with GraphQL concepts. If it is not the case - first learn about GraphQL on the official website .","title":"Prerequisites"},{"location":"getting-started/#installation","text":"Using composer , run: composer require webonyx/graphql-php","title":"Installation"},{"location":"getting-started/#upgrading","text":"We try to keep library releases backwards compatible when possible. For breaking changes we provide upgrade instructions .","title":"Upgrading"},{"location":"getting-started/#install-tools-optional","text":"While it is possible to communicate with GraphQL API using regular HTTP tools it is way more convenient for humans to use GraphiQL - an in-browser IDE for exploring GraphQL APIs. It provides syntax-highlighting, auto-completion and auto-generated documentation for GraphQL API. The easiest way to use it is to install one of the existing Google Chrome extensions: ChromeiQL GraphiQL Feen Alternatively, you can follow instructions on the GraphiQL page and install it locally.","title":"Install Tools (optional)"},{"location":"getting-started/#hello-world","text":"Let's create a type system that will be capable to process the following simple query: query { echo(message: \"Hello World\") } We need an object type with the field echo : use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\Type; $queryType = new ObjectType([ 'name' => 'Query', 'fields' => [ 'echo' => [ 'type' => Type::string(), 'args' => [ 'message' => Type::nonNull(Type::string()), ], 'resolve' => fn ($rootValue, array $args): string => $rootValue['prefix'] . $args['message'], ], ], ]); (Note: type definition can be expressed in different styles ) The interesting piece here is the resolve option of the field definition. It is responsible for returning a value of our field. Values of scalar fields will be directly included in the response while values of composite fields (objects, interfaces, unions) will be passed down to nested field resolvers (not in this example though). Now when our type is ready, let's create a GraphQL endpoint file for it graphql.php : use GraphQL\\GraphQL; use GraphQL\\Type\\Schema; $schema = new Schema([ 'query' => $queryType ]); $rawInput = file_get_contents('php://input'); $input = json_decode($rawInput, true); $query = $input['query']; $variableValues = isset($input['variables']) ? $input['variables'] : null; try { $rootValue = ['prefix' => 'You said: ']; $result = GraphQL::executeQuery($schema, $query, $rootValue, null, $variableValues); $output = $result->toArray(); } catch (\\Exception $e) { $output = [ 'errors' => [ [ 'message' => $e->getMessage() ] ] ]; } header('Content-Type: application/json'); echo json_encode($output); Our example is finished. Try it by running: php -S localhost:8080 graphql.php curl http://localhost:8080 -d '{\"query\": \"query { echo(message: \\\"Hello World\\\") }\" }' Check out the full source code of this example which also includes simple mutation. Check out the blog example for something which is closer to real-world apps or read about the details of schema definition .","title":"Hello World"},{"location":"getting-started/#next-steps","text":"Obviously hello world only scratches the surface of what is possible. To learn by example, check out the blog example which is quite close to real-world GraphQL hierarchies. For a deeper understanding of GraphQL in general, check out concepts . To delve right into the implementation, see schema definition .","title":"Next Steps"},{"location":"schema-definition-language/","text":"Schema Definition Language \u00b6 Since 0.9.0 The schema definition language is a convenient way to define your schema, especially with IDE autocompletion and syntax validation. You can define this separate from your PHP code, e.g. in a schema.graphql file: schema { query: Query mutation: Mutation } type Query { greetings(input: HelloInput!): String! } input HelloInput { firstName: String! lastName: String } In order to create schema instance out of this file, use GraphQL\\Utils\\BuildSchema : use GraphQL\\Utils\\BuildSchema; $contents = file_get_contents('schema.graphql'); $schema = BuildSchema::build($contents); By default, such schema is created without any resolvers. We have to rely on default field resolver and root value in order to execute a query against this schema. Defining resolvers \u00b6 Since 0.10.0 In order to enable Interfaces , Unions and custom field resolvers you can pass the second argument: type config decorator to schema builder. It accepts default type config produced by the builder and is expected to add missing options like resolveType for interface types or resolveField for object types. use GraphQL\\Utils\\BuildSchema; use GraphQL\\Language\\AST\\TypeDefinitionNode; $typeConfigDecorator = function (array $typeConfig, TypeDefinitionNode $typeDefinitionNode): array { $name = $typeConfig['name']; // ... add missing options to $typeConfig based on type $name return $typeConfig; }; $contents = file_get_contents('schema.graphql'); $schema = BuildSchema::build($contents, $typeConfigDecorator); Performance considerations \u00b6 Since 0.10.0 Method build() produces a lazy schema automatically, so it works efficiently even with very large schemas. But parsing type definition file on each request is suboptimal, so it is recommended to cache intermediate parsed representation of the schema for the production environment: use GraphQL\\Language\\Parser; use GraphQL\\Utils\\BuildSchema; use GraphQL\\Utils\\AST; $cacheFilename = 'cached_schema.php'; if (!file_exists($cacheFilename)) { $document = Parser::parse(file_get_contents('./schema.graphql')); file_put_contents($cacheFilename, \"<?php\\nreturn \" . var_export(AST::toArray($document), true) . \";\\n\"); } else { $document = AST::fromArray(require $cacheFilename); // fromArray() is a lazy operation as well } $typeConfigDecorator = function () {}; $schema = BuildSchema::build($document, $typeConfigDecorator);","title":"Schema Definition Language"},{"location":"schema-definition-language/#schema-definition-language","text":"Since 0.9.0 The schema definition language is a convenient way to define your schema, especially with IDE autocompletion and syntax validation. You can define this separate from your PHP code, e.g. in a schema.graphql file: schema { query: Query mutation: Mutation } type Query { greetings(input: HelloInput!): String! } input HelloInput { firstName: String! lastName: String } In order to create schema instance out of this file, use GraphQL\\Utils\\BuildSchema : use GraphQL\\Utils\\BuildSchema; $contents = file_get_contents('schema.graphql'); $schema = BuildSchema::build($contents); By default, such schema is created without any resolvers. We have to rely on default field resolver and root value in order to execute a query against this schema.","title":"Schema Definition Language"},{"location":"schema-definition-language/#defining-resolvers","text":"Since 0.10.0 In order to enable Interfaces , Unions and custom field resolvers you can pass the second argument: type config decorator to schema builder. It accepts default type config produced by the builder and is expected to add missing options like resolveType for interface types or resolveField for object types. use GraphQL\\Utils\\BuildSchema; use GraphQL\\Language\\AST\\TypeDefinitionNode; $typeConfigDecorator = function (array $typeConfig, TypeDefinitionNode $typeDefinitionNode): array { $name = $typeConfig['name']; // ... add missing options to $typeConfig based on type $name return $typeConfig; }; $contents = file_get_contents('schema.graphql'); $schema = BuildSchema::build($contents, $typeConfigDecorator);","title":"Defining resolvers"},{"location":"schema-definition-language/#performance-considerations","text":"Since 0.10.0 Method build() produces a lazy schema automatically, so it works efficiently even with very large schemas. But parsing type definition file on each request is suboptimal, so it is recommended to cache intermediate parsed representation of the schema for the production environment: use GraphQL\\Language\\Parser; use GraphQL\\Utils\\BuildSchema; use GraphQL\\Utils\\AST; $cacheFilename = 'cached_schema.php'; if (!file_exists($cacheFilename)) { $document = Parser::parse(file_get_contents('./schema.graphql')); file_put_contents($cacheFilename, \"<?php\\nreturn \" . var_export(AST::toArray($document), true) . \";\\n\"); } else { $document = AST::fromArray(require $cacheFilename); // fromArray() is a lazy operation as well } $typeConfigDecorator = function () {}; $schema = BuildSchema::build($document, $typeConfigDecorator);","title":"Performance considerations"},{"location":"schema-definition/","text":"Schema Definition \u00b6 The schema is a container of your type hierarchy, which accepts root types in a constructor and provides methods for receiving information about your types to internal GraphQL tools. In graphql-php , the schema is an instance of GraphQL\\Type\\Schema : use GraphQL\\Type\\Schema; $schema = new Schema([ 'query' => $queryType, 'mutation' => $mutationType, ]); See possible constructor options below . Query and Mutation types \u00b6 The schema consists of two root types: Query type is a surface of your read API Mutation type (optional) exposes write API by declaring all possible mutations in your app. Query and Mutation types are regular object types containing root-level fields of your API: use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\Type; $queryType = new ObjectType([ 'name' => 'Query', 'fields' => [ 'hello' => [ 'type' => Type::string(), 'resolve' => fn () => 'Hello World!', ], 'hero' => [ 'type' => $characterInterface, 'args' => [ 'episode' => [ 'type' => $episodeEnum, ], ], 'resolve' => fn ($rootValue, array $args): Hero => StarWarsData::getHero($args['episode'] ?? null), ] ] ]); $mutationType = new ObjectType([ 'name' => 'Mutation', 'fields' => [ 'createReview' => [ 'type' => $createReviewOutput, 'args' => [ 'episode' => Type::nonNull($episodeEnum), 'review' => Type::nonNull($reviewInputObject), ], // TODO 'resolve' => fn ($rootValue, array $args): Review => StarWarsData::createReview($args['episode'], $args['review']), ] ] ]); Keep in mind that other than the special meaning of declaring a surface area of your API, those types are the same as any other object type , and their fields work exactly the same way. Mutation type is also just a regular object type. The difference is in semantics. Field names of Mutation type are usually verbs and they almost always have arguments - quite often with complex input values (see Mutations and Input Types for details). Configuration Options \u00b6 The schema constructor expects an instance of GraphQL\\Type\\SchemaConfig or an array with the following options: Option Type Notes query ObjectType Required. Object type (usually named \"Query\") containing root-level fields of your read API mutation ObjectType Object type (usually named \"Mutation\") containing root-level fields of your write API subscription ObjectType Reserved for future subscriptions implementation. Currently presented for compatibility with introspection query of graphql-js , used by various clients (like Relay or GraphiQL) directives array<Directive> A full list of directives supported by your schema. By default, contains built-in @skip and @include directives. If you pass your own directives and still want to use built-in directives - add them explicitly. For example: array_merge(GraphQL::getStandardDirectives(), [$myCustomDirective]); types array<ObjectType> List of object types which cannot be detected by graphql-php during static schema analysis. Most often this happens when the object type is never referenced in fields directly but is still a part of a schema because it implements an interface which resolves to this object type in its resolveType callable. Note that you are not required to pass all of your types here - it is simply a workaround for concrete a use-case. typeLoader callable(string $name): Type Expected to return a type instance given the name. Must always return the same instance if called multiple times, see lazy loading . See section below on lazy type loading. Using config class \u00b6 If you prefer a fluid interface for the config with auto-completion in IDE and static time validation, use GraphQL\\Type\\SchemaConfig instead of an array: use GraphQL\\Type\\SchemaConfig; use GraphQL\\Type\\Schema; $config = SchemaConfig::create() ->setQuery($myQueryType) ->setTypeLoader($myTypeLoader); $schema = new Schema($config); Lazy loading of types \u00b6 By default, the schema will scan all of your type, field and argument definitions to serve GraphQL queries. It may cause performance overhead when there are many types in the schema. In this case, it is recommended to pass the typeLoader option to the schema constructor and define all of your object fields as callbacks. Type loading is very similar to PHP class loading, but keep in mind that the typeLoader must always return the same instance of a type. A good way to ensure this is to use a type registry: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Schema; class TypeRegistry { /** * @var array<string, Type> */ private array $types = []; public function get(string $name): Type { return $this->types[$name] ??= $this->{$name}(); } private function MyTypeA(): ObjectType { return new ObjectType([ 'name' => 'MyTypeA', 'fields' => fn() => [ 'b' => [ 'type' => $this->get('MyTypeB') ], ] ]); } private function MyTypeB(): ObjectType { // ... } } $typeRegistry = new TypeRegistry(); $schema = new Schema([ 'query' => $typeRegistry->get('Query'), 'typeLoader' => static fn (string $name): Type => $typeRegistry->get($name), ]); You can automate this registry if you wish to reduce boilerplate or even introduce a Dependency Injection Container if your types have other dependencies. Alternatively, all methods of the registry could be static - then there is no need to pass it in the constructor - instead use TypeRegistry::myAType() in your type definitions. Schema Validation \u00b6 By default, the schema is created with only shallow validation of type and field definitions (because validation requires a full schema scan and is very costly on bigger schemas). There is a special method assertValid() on the schema instance which throws GraphQL\\Error\\InvariantViolation exception when it encounters any error, like: Invalid types used for fields/arguments Missing interface implementations Invalid interface implementations Other schema errors... Schema validation is supposed to be used in CLI commands or during a build step of your app. Don't call it in web requests in production. Usage example: try { $schema = new GraphQL\\Type\\Schema([ 'query' => $myQueryType ]); $schema->assertValid(); } catch (GraphQL\\Error\\InvariantViolation $e) { echo $e->getMessage(); }","title":"Schema Definition"},{"location":"schema-definition/#schema-definition","text":"The schema is a container of your type hierarchy, which accepts root types in a constructor and provides methods for receiving information about your types to internal GraphQL tools. In graphql-php , the schema is an instance of GraphQL\\Type\\Schema : use GraphQL\\Type\\Schema; $schema = new Schema([ 'query' => $queryType, 'mutation' => $mutationType, ]); See possible constructor options below .","title":"Schema Definition"},{"location":"schema-definition/#query-and-mutation-types","text":"The schema consists of two root types: Query type is a surface of your read API Mutation type (optional) exposes write API by declaring all possible mutations in your app. Query and Mutation types are regular object types containing root-level fields of your API: use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\Type; $queryType = new ObjectType([ 'name' => 'Query', 'fields' => [ 'hello' => [ 'type' => Type::string(), 'resolve' => fn () => 'Hello World!', ], 'hero' => [ 'type' => $characterInterface, 'args' => [ 'episode' => [ 'type' => $episodeEnum, ], ], 'resolve' => fn ($rootValue, array $args): Hero => StarWarsData::getHero($args['episode'] ?? null), ] ] ]); $mutationType = new ObjectType([ 'name' => 'Mutation', 'fields' => [ 'createReview' => [ 'type' => $createReviewOutput, 'args' => [ 'episode' => Type::nonNull($episodeEnum), 'review' => Type::nonNull($reviewInputObject), ], // TODO 'resolve' => fn ($rootValue, array $args): Review => StarWarsData::createReview($args['episode'], $args['review']), ] ] ]); Keep in mind that other than the special meaning of declaring a surface area of your API, those types are the same as any other object type , and their fields work exactly the same way. Mutation type is also just a regular object type. The difference is in semantics. Field names of Mutation type are usually verbs and they almost always have arguments - quite often with complex input values (see Mutations and Input Types for details).","title":"Query and Mutation types"},{"location":"schema-definition/#configuration-options","text":"The schema constructor expects an instance of GraphQL\\Type\\SchemaConfig or an array with the following options: Option Type Notes query ObjectType Required. Object type (usually named \"Query\") containing root-level fields of your read API mutation ObjectType Object type (usually named \"Mutation\") containing root-level fields of your write API subscription ObjectType Reserved for future subscriptions implementation. Currently presented for compatibility with introspection query of graphql-js , used by various clients (like Relay or GraphiQL) directives array<Directive> A full list of directives supported by your schema. By default, contains built-in @skip and @include directives. If you pass your own directives and still want to use built-in directives - add them explicitly. For example: array_merge(GraphQL::getStandardDirectives(), [$myCustomDirective]); types array<ObjectType> List of object types which cannot be detected by graphql-php during static schema analysis. Most often this happens when the object type is never referenced in fields directly but is still a part of a schema because it implements an interface which resolves to this object type in its resolveType callable. Note that you are not required to pass all of your types here - it is simply a workaround for concrete a use-case. typeLoader callable(string $name): Type Expected to return a type instance given the name. Must always return the same instance if called multiple times, see lazy loading . See section below on lazy type loading.","title":"Configuration Options"},{"location":"schema-definition/#using-config-class","text":"If you prefer a fluid interface for the config with auto-completion in IDE and static time validation, use GraphQL\\Type\\SchemaConfig instead of an array: use GraphQL\\Type\\SchemaConfig; use GraphQL\\Type\\Schema; $config = SchemaConfig::create() ->setQuery($myQueryType) ->setTypeLoader($myTypeLoader); $schema = new Schema($config);","title":"Using config class"},{"location":"schema-definition/#lazy-loading-of-types","text":"By default, the schema will scan all of your type, field and argument definitions to serve GraphQL queries. It may cause performance overhead when there are many types in the schema. In this case, it is recommended to pass the typeLoader option to the schema constructor and define all of your object fields as callbacks. Type loading is very similar to PHP class loading, but keep in mind that the typeLoader must always return the same instance of a type. A good way to ensure this is to use a type registry: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Schema; class TypeRegistry { /** * @var array<string, Type> */ private array $types = []; public function get(string $name): Type { return $this->types[$name] ??= $this->{$name}(); } private function MyTypeA(): ObjectType { return new ObjectType([ 'name' => 'MyTypeA', 'fields' => fn() => [ 'b' => [ 'type' => $this->get('MyTypeB') ], ] ]); } private function MyTypeB(): ObjectType { // ... } } $typeRegistry = new TypeRegistry(); $schema = new Schema([ 'query' => $typeRegistry->get('Query'), 'typeLoader' => static fn (string $name): Type => $typeRegistry->get($name), ]); You can automate this registry if you wish to reduce boilerplate or even introduce a Dependency Injection Container if your types have other dependencies. Alternatively, all methods of the registry could be static - then there is no need to pass it in the constructor - instead use TypeRegistry::myAType() in your type definitions.","title":"Lazy loading of types"},{"location":"schema-definition/#schema-validation","text":"By default, the schema is created with only shallow validation of type and field definitions (because validation requires a full schema scan and is very costly on bigger schemas). There is a special method assertValid() on the schema instance which throws GraphQL\\Error\\InvariantViolation exception when it encounters any error, like: Invalid types used for fields/arguments Missing interface implementations Invalid interface implementations Other schema errors... Schema validation is supposed to be used in CLI commands or during a build step of your app. Don't call it in web requests in production. Usage example: try { $schema = new GraphQL\\Type\\Schema([ 'query' => $myQueryType ]); $schema->assertValid(); } catch (GraphQL\\Error\\InvariantViolation $e) { echo $e->getMessage(); }","title":"Schema Validation"},{"location":"security/","text":"Query Complexity Analysis \u00b6 This is a PHP port of Query Complexity Analysis in Sangria implementation. Complexity analysis is a separate validation rule which calculates query complexity score before execution. Every field in the query gets a default score 1 (including ObjectType nodes). Total complexity of the query is the sum of all field scores. For example, the complexity of introspection query is 109 . If this score exceeds a threshold, a query is not executed and an error is returned instead. Complexity analysis is disabled by default. To enabled it, add validation rule: use GraphQL\\GraphQL; use GraphQL\\Validator\\Rules\\QueryComplexity; use GraphQL\\Validator\\DocumentValidator; $rule = new QueryComplexity($maxQueryComplexity = 100); DocumentValidator::addRule($rule); GraphQL::executeQuery(/*...*/); This will set the rule globally. Alternatively, you can provide validation rules per execution . To customize field score add complexity function to field definition: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $type = new ObjectType([ 'name' => 'MyType', 'fields' => [ 'someList' => [ 'type' => Type::listOf(Type::string()), 'args' => [ 'limit' => [ 'type' => Type::int(), 'defaultValue' => 10 ] ], 'complexity' => fn (int $childrenComplexity, array $args): int => $childrenComplexity * $args['limit'], ] ] ]); Limiting Query Depth \u00b6 This is a PHP port of Limiting Query Depth in Sangria implementation. For example, max depth of the introspection query is 7 . It is disabled by default. To enable it, add following validation rule: use GraphQL\\GraphQL; use GraphQL\\Validator\\Rules\\QueryDepth; use GraphQL\\Validator\\DocumentValidator; $rule = new QueryDepth($maxDepth = 10); DocumentValidator::addRule($rule); GraphQL::executeQuery(/*...*/); This will set the rule globally. Alternatively, you can provide validation rules per execution . Disabling Introspection \u00b6 Introspection is a mechanism for fetching schema structure. It is used by tools like GraphiQL for auto-completion, query validation, etc. Introspection is enabled by default. It means that anybody can get a full description of your schema by sending a special query containing meta fields __type and __schema . If you are not planning to expose your API to the general public, it makes sense to disable this feature. GraphQL PHP provides you separate validation rule which prohibits queries that contain __type or __schema fields. To disable introspection, add following rule: use GraphQL\\GraphQL; use GraphQL\\Validator\\Rules\\DisableIntrospection; use GraphQL\\Validator\\DocumentValidator; DocumentValidator::addRule(new DisableIntrospection()); GraphQL::executeQuery(/*...*/); This will set the rule globally. Alternatively, you can provide validation rules per execution .","title":"Security"},{"location":"security/#query-complexity-analysis","text":"This is a PHP port of Query Complexity Analysis in Sangria implementation. Complexity analysis is a separate validation rule which calculates query complexity score before execution. Every field in the query gets a default score 1 (including ObjectType nodes). Total complexity of the query is the sum of all field scores. For example, the complexity of introspection query is 109 . If this score exceeds a threshold, a query is not executed and an error is returned instead. Complexity analysis is disabled by default. To enabled it, add validation rule: use GraphQL\\GraphQL; use GraphQL\\Validator\\Rules\\QueryComplexity; use GraphQL\\Validator\\DocumentValidator; $rule = new QueryComplexity($maxQueryComplexity = 100); DocumentValidator::addRule($rule); GraphQL::executeQuery(/*...*/); This will set the rule globally. Alternatively, you can provide validation rules per execution . To customize field score add complexity function to field definition: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $type = new ObjectType([ 'name' => 'MyType', 'fields' => [ 'someList' => [ 'type' => Type::listOf(Type::string()), 'args' => [ 'limit' => [ 'type' => Type::int(), 'defaultValue' => 10 ] ], 'complexity' => fn (int $childrenComplexity, array $args): int => $childrenComplexity * $args['limit'], ] ] ]);","title":"Query Complexity Analysis"},{"location":"security/#limiting-query-depth","text":"This is a PHP port of Limiting Query Depth in Sangria implementation. For example, max depth of the introspection query is 7 . It is disabled by default. To enable it, add following validation rule: use GraphQL\\GraphQL; use GraphQL\\Validator\\Rules\\QueryDepth; use GraphQL\\Validator\\DocumentValidator; $rule = new QueryDepth($maxDepth = 10); DocumentValidator::addRule($rule); GraphQL::executeQuery(/*...*/); This will set the rule globally. Alternatively, you can provide validation rules per execution .","title":"Limiting Query Depth"},{"location":"security/#disabling-introspection","text":"Introspection is a mechanism for fetching schema structure. It is used by tools like GraphiQL for auto-completion, query validation, etc. Introspection is enabled by default. It means that anybody can get a full description of your schema by sending a special query containing meta fields __type and __schema . If you are not planning to expose your API to the general public, it makes sense to disable this feature. GraphQL PHP provides you separate validation rule which prohibits queries that contain __type or __schema fields. To disable introspection, add following rule: use GraphQL\\GraphQL; use GraphQL\\Validator\\Rules\\DisableIntrospection; use GraphQL\\Validator\\DocumentValidator; DocumentValidator::addRule(new DisableIntrospection()); GraphQL::executeQuery(/*...*/); This will set the rule globally. Alternatively, you can provide validation rules per execution .","title":"Disabling Introspection"},{"location":"type-definitions/","text":"Type Definitions \u00b6 graphql-php represents a type as a class instance from the GraphQL\\Type\\Definition namespace: ObjectType InterfaceType UnionType InputObjectType ScalarType EnumType Input vs. Output Types \u00b6 All types in GraphQL are of two categories: input and output . Output types (or field types) are: Scalar , Enum , Object , Interface , Union Input types (or argument types) are: Scalar , Enum , Inputs Obviously, NonNull and List types belong to both categories depending on their inner type. Definition styles \u00b6 Several styles of type definitions are supported depending on your preferences. Inline definitions \u00b6 use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\Type; $myType = new ObjectType([ 'name' => 'MyType', 'fields' => [ 'id' => Type::id() ] ]); Class per type \u00b6 use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\Type; class MyType extends ObjectType { public function __construct() { $config = [ // Note: 'name' is not needed in this form: // it will be inferred from class name by omitting namespace and dropping \"Type\" suffix 'fields' => [ 'id' => Type::id() ] ]; parent::__construct($config); } } Schema definition language \u00b6 schema { query: Query mutation: Mutation } type Query { greetings(input: HelloInput!): String! } input HelloInput { firstName: String! lastName: String } Read more about building an executable schema using schema definition language .","title":"Introduction"},{"location":"type-definitions/#type-definitions","text":"graphql-php represents a type as a class instance from the GraphQL\\Type\\Definition namespace: ObjectType InterfaceType UnionType InputObjectType ScalarType EnumType","title":"Type Definitions"},{"location":"type-definitions/#input-vs-output-types","text":"All types in GraphQL are of two categories: input and output . Output types (or field types) are: Scalar , Enum , Object , Interface , Union Input types (or argument types) are: Scalar , Enum , Inputs Obviously, NonNull and List types belong to both categories depending on their inner type.","title":"Input vs. Output Types"},{"location":"type-definitions/#definition-styles","text":"Several styles of type definitions are supported depending on your preferences.","title":"Definition styles"},{"location":"type-definitions/#inline-definitions","text":"use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\Type; $myType = new ObjectType([ 'name' => 'MyType', 'fields' => [ 'id' => Type::id() ] ]);","title":"Inline definitions"},{"location":"type-definitions/#class-per-type","text":"use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\Type; class MyType extends ObjectType { public function __construct() { $config = [ // Note: 'name' is not needed in this form: // it will be inferred from class name by omitting namespace and dropping \"Type\" suffix 'fields' => [ 'id' => Type::id() ] ]; parent::__construct($config); } }","title":"Class per type"},{"location":"type-definitions/#schema-definition-language","text":"schema { query: Query mutation: Mutation } type Query { greetings(input: HelloInput!): String! } input HelloInput { firstName: String! lastName: String } Read more about building an executable schema using schema definition language .","title":"Schema definition language"},{"location":"type-definitions/directives/","text":"Built-in directives \u00b6 The directive is a way for a client to give GraphQL server additional context and hints on how to execute the query. The directive can be attached to a field or fragment and can affect the execution of the query in any way the server desires. GraphQL specification includes two built-in directives: @include(if: Boolean) Only include this field or fragment in the result if the argument is true @skip(if: Boolean) Skip this field or fragment if the argument is true For example: query Hero($episode: Episode, $withFriends: Boolean!) { hero(episode: $episode) { name friends @include(if: $withFriends) { name } } } Here if $withFriends variable is set to false - friends section will be ignored and excluded from the response. Important implementation detail: those fields will never be executed (not just removed from response after execution). Custom directives \u00b6 graphql-php supports custom directives even though their presence does not affect the execution of fields. You can use GraphQL\\Type\\Definition\\ResolveInfo in field resolvers to modify the output depending on those directives or perform statistics collection. Other use case is your own query validation rules relying on custom directives. In graphql-php custom directive is an instance of GraphQL\\Type\\Definition\\Directive (or one of its subclasses) which accepts an array of following options: use GraphQL\\Language\\DirectiveLocation; use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\Directive; $trackDirective = new Directive([ 'name' => 'track', 'description' => 'Instruction to record usage of the field by client', 'locations' => [ DirectiveLocation::FIELD, ], 'args' => [ 'details' => [ 'type' => Type::string(), 'description' => 'String with additional details of field usage scenario', 'defaultValue' => '' ] ] ]); See possible directive locations in GraphQL\\Language\\DirectiveLocation .","title":"Directives"},{"location":"type-definitions/directives/#built-in-directives","text":"The directive is a way for a client to give GraphQL server additional context and hints on how to execute the query. The directive can be attached to a field or fragment and can affect the execution of the query in any way the server desires. GraphQL specification includes two built-in directives: @include(if: Boolean) Only include this field or fragment in the result if the argument is true @skip(if: Boolean) Skip this field or fragment if the argument is true For example: query Hero($episode: Episode, $withFriends: Boolean!) { hero(episode: $episode) { name friends @include(if: $withFriends) { name } } } Here if $withFriends variable is set to false - friends section will be ignored and excluded from the response. Important implementation detail: those fields will never be executed (not just removed from response after execution).","title":"Built-in directives"},{"location":"type-definitions/directives/#custom-directives","text":"graphql-php supports custom directives even though their presence does not affect the execution of fields. You can use GraphQL\\Type\\Definition\\ResolveInfo in field resolvers to modify the output depending on those directives or perform statistics collection. Other use case is your own query validation rules relying on custom directives. In graphql-php custom directive is an instance of GraphQL\\Type\\Definition\\Directive (or one of its subclasses) which accepts an array of following options: use GraphQL\\Language\\DirectiveLocation; use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\Directive; $trackDirective = new Directive([ 'name' => 'track', 'description' => 'Instruction to record usage of the field by client', 'locations' => [ DirectiveLocation::FIELD, ], 'args' => [ 'details' => [ 'type' => Type::string(), 'description' => 'String with additional details of field usage scenario', 'defaultValue' => '' ] ] ]); See possible directive locations in GraphQL\\Language\\DirectiveLocation .","title":"Custom directives"},{"location":"type-definitions/enums/","text":"Enum Type Definition \u00b6 Enumeration types are a special kind of scalar that is restricted to a particular set of allowed values. Writing Enum Types \u00b6 In graphql-php enum type is an instance of GraphQL\\Type\\Definition\\EnumType which accepts configuration array in constructor: use GraphQL\\Type\\Definition\\EnumType; $episodeEnum = new EnumType([ 'name' => 'Episode', 'description' => 'One of the films in the Star Wars Trilogy', 'values' => [ 'NEWHOPE' => [ 'value' => 4, 'description' => 'Released in 1977.' ], 'EMPIRE' => [ 'value' => 5, 'description' => 'Released in 1980.' ], 'JEDI' => [ 'value' => 6, 'description' => 'Released in 1983.' ], ] ]); This example uses an inline style for Enum Type definition, but you can also use inheritance or schema definition language . Configuration options \u00b6 Enum Type constructor accepts an array with following options: Option Type Notes name string Required. Name of the type. When not set - inferred from array key (read about shorthand field definition below) description string Plain-text description of the type for clients (e.g. used by GraphiQL for auto-generated documentation) values array List of enumerated items, see below for expected structure of each entry Each entry of values array in turn accepts following options: Option Type Notes name string Required. Name of the item. When not set - inferred from array key (read about shorthand field definition below) value mixed Internal representation of enum item in your application (could be any value, including complex objects or callbacks) description string Plain-text description of enum value for clients (e.g. used by GraphiQL for auto-generated documentation) deprecationReason string Text describing why this enum value is deprecated. When not empty - item will not be returned by introspection queries (unless forced) Construction from PHP enum \u00b6 You can reuse your existing PHP enums in GraphQL. Leverage PHP attributes to add descriptions and deprecate values: use GraphQL\\Type\\Definition\\Deprecated; use GraphQL\\Type\\Definition\\Description; #[Description(description: 'Sweet and juicy.')] enum Fruit { #[Description(description: 'Rich in potassium.')] case BANANA; #[Deprecated(reason: 'Too sour.')] case CITRON; } PhpDocs will be used as descriptions if present, but are overridden by the Description attribute. Wrap them with GraphQL\\Type\\Definition\\PhpEnumType to use them in a GraphQL schema: use GraphQL\\Type\\Definition\\PhpEnumType; $fruitEnumType = new PhpEnumType(Fruit::class); The following type will be deduced from Fruit : \"\"\" Sweet and juicy. \"\"\" enum Fruit { \"\"\" Rich in potassium. \"\"\" BANANA CITRON @deprecated(reason: \"Too sour.\") } Conversion rules: Client-given arguments will be converted to enum instances Returned output values are expected to be enum instances Shorthand definitions \u00b6 If internal representation of enumerated item is the same as item name, then you can use following shorthand for definition: use GraphQL\\Type\\Definition\\EnumType; $episodeEnum = new EnumType([ 'name' => 'Episode', 'description' => 'One of the films in the Star Wars Trilogy', 'values' => ['NEWHOPE', 'EMPIRE', 'JEDI'] ]); which is equivalent of: use GraphQL\\Type\\Definition\\EnumType; $episodeEnum = new EnumType([ 'name' => 'Episode', 'description' => 'One of the films in the Star Wars Trilogy', 'values' => [ 'NEWHOPE' => ['value' => 'NEWHOPE'], 'EMPIRE' => ['value' => 'EMPIRE'], 'JEDI' => ['value' => 'JEDI'] ] ]); which is in turn equivalent of the full form: use GraphQL\\Type\\Definition\\EnumType; $episodeEnum = new EnumType([ 'name' => 'Episode', 'description' => 'One of the films in the Star Wars Trilogy', 'values' => [ ['name' => 'NEWHOPE', 'value' => 'NEWHOPE'], ['name' => 'EMPIRE', 'value' => 'EMPIRE'], ['name' => 'JEDI', 'value' => 'JEDI'] ] ]); Field Resolution \u00b6 When object field is of Enum Type, field resolver is expected to return an internal representation of corresponding Enum item ( value in config). graphql-php will then serialize this value to name to include in response: use GraphQL\\Type\\Definition\\EnumType; use GraphQL\\Type\\Definition\\ObjectType; $episodeEnum = new EnumType([ 'name' => 'Episode', 'description' => 'One of the films in the Star Wars Trilogy', 'values' => [ 'NEWHOPE' => [ 'value' => 4, 'description' => 'Released in 1977.' ], 'EMPIRE' => [ 'value' => 5, 'description' => 'Released in 1980.' ], 'JEDI' => [ 'value' => 6, 'description' => 'Released in 1983.' ], ] ]); $heroType = new ObjectType([ 'name' => 'Hero', 'fields' => [ 'appearsIn' => [ 'type' => $episodeEnum, // Actual entry in response will be 'appearsIn' => 'EMPIRE' 'resolve' => fn (): int => 5, ] ] ]); The Reverse is true when the enum is used as input type (e.g. as field argument). GraphQL will treat enum input as name and convert it into value before passing to your app. For example, given object type definition: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $heroType = new ObjectType([ 'name' => 'Hero', 'fields' => [ 'appearsIn' => [ 'type' => Type::boolean(), 'args' => [ 'episode' => Type::nonNull($enumType) ], 'resolve' => fn ($hero, array $args): bool => $args['episode'] === 5, ] ] ]); Then following query: fragment on Hero { appearsInNewHope: appearsIn(NEWHOPE) appearsInEmpire: appearsIn(EMPIRE) } will return: [ 'appearsInNewHope' => false, 'appearsInEmpire' => true ]","title":"Enums"},{"location":"type-definitions/enums/#enum-type-definition","text":"Enumeration types are a special kind of scalar that is restricted to a particular set of allowed values.","title":"Enum Type Definition"},{"location":"type-definitions/enums/#writing-enum-types","text":"In graphql-php enum type is an instance of GraphQL\\Type\\Definition\\EnumType which accepts configuration array in constructor: use GraphQL\\Type\\Definition\\EnumType; $episodeEnum = new EnumType([ 'name' => 'Episode', 'description' => 'One of the films in the Star Wars Trilogy', 'values' => [ 'NEWHOPE' => [ 'value' => 4, 'description' => 'Released in 1977.' ], 'EMPIRE' => [ 'value' => 5, 'description' => 'Released in 1980.' ], 'JEDI' => [ 'value' => 6, 'description' => 'Released in 1983.' ], ] ]); This example uses an inline style for Enum Type definition, but you can also use inheritance or schema definition language .","title":"Writing Enum Types"},{"location":"type-definitions/enums/#configuration-options","text":"Enum Type constructor accepts an array with following options: Option Type Notes name string Required. Name of the type. When not set - inferred from array key (read about shorthand field definition below) description string Plain-text description of the type for clients (e.g. used by GraphiQL for auto-generated documentation) values array List of enumerated items, see below for expected structure of each entry Each entry of values array in turn accepts following options: Option Type Notes name string Required. Name of the item. When not set - inferred from array key (read about shorthand field definition below) value mixed Internal representation of enum item in your application (could be any value, including complex objects or callbacks) description string Plain-text description of enum value for clients (e.g. used by GraphiQL for auto-generated documentation) deprecationReason string Text describing why this enum value is deprecated. When not empty - item will not be returned by introspection queries (unless forced)","title":"Configuration options"},{"location":"type-definitions/enums/#construction-from-php-enum","text":"You can reuse your existing PHP enums in GraphQL. Leverage PHP attributes to add descriptions and deprecate values: use GraphQL\\Type\\Definition\\Deprecated; use GraphQL\\Type\\Definition\\Description; #[Description(description: 'Sweet and juicy.')] enum Fruit { #[Description(description: 'Rich in potassium.')] case BANANA; #[Deprecated(reason: 'Too sour.')] case CITRON; } PhpDocs will be used as descriptions if present, but are overridden by the Description attribute. Wrap them with GraphQL\\Type\\Definition\\PhpEnumType to use them in a GraphQL schema: use GraphQL\\Type\\Definition\\PhpEnumType; $fruitEnumType = new PhpEnumType(Fruit::class); The following type will be deduced from Fruit : \"\"\" Sweet and juicy. \"\"\" enum Fruit { \"\"\" Rich in potassium. \"\"\" BANANA CITRON @deprecated(reason: \"Too sour.\") } Conversion rules: Client-given arguments will be converted to enum instances Returned output values are expected to be enum instances","title":"Construction from PHP enum"},{"location":"type-definitions/enums/#shorthand-definitions","text":"If internal representation of enumerated item is the same as item name, then you can use following shorthand for definition: use GraphQL\\Type\\Definition\\EnumType; $episodeEnum = new EnumType([ 'name' => 'Episode', 'description' => 'One of the films in the Star Wars Trilogy', 'values' => ['NEWHOPE', 'EMPIRE', 'JEDI'] ]); which is equivalent of: use GraphQL\\Type\\Definition\\EnumType; $episodeEnum = new EnumType([ 'name' => 'Episode', 'description' => 'One of the films in the Star Wars Trilogy', 'values' => [ 'NEWHOPE' => ['value' => 'NEWHOPE'], 'EMPIRE' => ['value' => 'EMPIRE'], 'JEDI' => ['value' => 'JEDI'] ] ]); which is in turn equivalent of the full form: use GraphQL\\Type\\Definition\\EnumType; $episodeEnum = new EnumType([ 'name' => 'Episode', 'description' => 'One of the films in the Star Wars Trilogy', 'values' => [ ['name' => 'NEWHOPE', 'value' => 'NEWHOPE'], ['name' => 'EMPIRE', 'value' => 'EMPIRE'], ['name' => 'JEDI', 'value' => 'JEDI'] ] ]);","title":"Shorthand definitions"},{"location":"type-definitions/enums/#field-resolution","text":"When object field is of Enum Type, field resolver is expected to return an internal representation of corresponding Enum item ( value in config). graphql-php will then serialize this value to name to include in response: use GraphQL\\Type\\Definition\\EnumType; use GraphQL\\Type\\Definition\\ObjectType; $episodeEnum = new EnumType([ 'name' => 'Episode', 'description' => 'One of the films in the Star Wars Trilogy', 'values' => [ 'NEWHOPE' => [ 'value' => 4, 'description' => 'Released in 1977.' ], 'EMPIRE' => [ 'value' => 5, 'description' => 'Released in 1980.' ], 'JEDI' => [ 'value' => 6, 'description' => 'Released in 1983.' ], ] ]); $heroType = new ObjectType([ 'name' => 'Hero', 'fields' => [ 'appearsIn' => [ 'type' => $episodeEnum, // Actual entry in response will be 'appearsIn' => 'EMPIRE' 'resolve' => fn (): int => 5, ] ] ]); The Reverse is true when the enum is used as input type (e.g. as field argument). GraphQL will treat enum input as name and convert it into value before passing to your app. For example, given object type definition: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $heroType = new ObjectType([ 'name' => 'Hero', 'fields' => [ 'appearsIn' => [ 'type' => Type::boolean(), 'args' => [ 'episode' => Type::nonNull($enumType) ], 'resolve' => fn ($hero, array $args): bool => $args['episode'] === 5, ] ] ]); Then following query: fragment on Hero { appearsInNewHope: appearsIn(NEWHOPE) appearsInEmpire: appearsIn(EMPIRE) } will return: [ 'appearsInNewHope' => false, 'appearsInEmpire' => true ]","title":"Field Resolution"},{"location":"type-definitions/inputs/","text":"Input Object Type Definition \u00b6 The GraphQL specification defines Input Object Type for complex inputs. It is similar to ObjectType except that it's fields have no args or resolve options and their type must be input type. Writing Input Object Types \u00b6 In graphql-php Input Object Type is an instance of GraphQL\\Type\\Definition\\InputObjectType (or one of its subclasses) which accepts configuration array in its constructor: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\InputObjectType; $filters = new InputObjectType([ 'name' => 'StoryFiltersInput', 'fields' => [ 'author' => [ 'type' => Type::id(), 'description' => 'Only show stories with this author id' ], 'popular' => [ 'type' => Type::boolean(), 'description' => 'Only show popular stories (liked by several people)' ], 'tags' => [ 'type' => Type::listOf(Type::string()), 'description' => 'Only show stories which contain all of those tags' ] ] ]); Every field may be of other InputObjectType (thus complex hierarchies of inputs are possible) Configuration options \u00b6 The constructor of InputObjectType accepts an array with the following options: Option Type Notes name string Required. Unique name of this object type within Schema fields array or callable Required . An array describing object fields or callable returning such an array (see below). description string Plain-text description of this type for clients (e.g. used by GraphiQL for auto-generated documentation) parseValue callable(array<string, mixed>): mixed Converts incoming values from their array representation to something else (e.g. a value object) Every field is an array with following entries: Option Type Notes name string Required. Name of the input field. When not set - inferred from fields array key type Type Required. Instance of one of Input Types ( Scalar , Enum , InputObjectType + any combination of those with nonNull and listOf modifiers) description string Plain-text description of this input field for clients (e.g. used by GraphiQL for auto-generated documentation) defaultValue scalar Default value of this input field. Use the internal value if specifying a default for an enum type Using Input Object Type \u00b6 In the example above we defined our InputObjectType. Now let's use it in one of field arguments: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $queryType = new ObjectType([ 'name' => 'Query', 'fields' => [ 'stories' => [ 'type' => Type::listOf($storyType), 'args' => [ 'filters' => [ 'type' => $filters, 'defaultValue' => [ 'popular' => true ] ] ], 'resolve' => fn ($rootValue, array $args): array => DataSource::filterStories($args['filters']), ] ] ]); (note that you can define defaultValue for fields with complex inputs as associative array). Then GraphQL query could include filters as literal value: { stories(filters: { author: \"1\", popular: false }) } Or as query variable: query ($filters: StoryFiltersInput!) { stories(filters: $filters) } $variables = [ 'filters' => [ \"author\" => \"1\", \"popular\" => false ] ]; graphql-php will validate the input against your InputObjectType definition and pass it to your resolver as $args['filters'] Converting input object array to value object \u00b6 If you want more type safety you can choose to parse the input array into a value object. use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\InputObjectType; final class StoryFiltersInput { public string $author; public ?bool $popular; public array $tags; public function __construct(string $author, ?bool $popular, array $tags) { $this->author = $author; $this->popular = $popular; $this->tag = $tag; } } $filters = new InputObjectType([ 'name' => 'StoryFiltersInput', 'fields' => [ 'author' => [ 'type' => Type::nonNull(Type::string()), ], 'popular' => [ 'type' => Type::boolean(), ], 'tags' => [ 'type' => Type::nonNull(Type::listOf(Type::string())), ] ], 'parseValue' => fn(array $values) => new StoryFiltersInput( $values['author'], $values['popular'] ?? null, $values['tags'] ), ]); The value of $args['filters'] will now be an instance of StoryFiltersInput . The incoming values are converted using a depth-first traversal. Thus, nested input values will be passed through their respective parseValue functions before the parent receives their value.","title":"Inputs"},{"location":"type-definitions/inputs/#input-object-type-definition","text":"The GraphQL specification defines Input Object Type for complex inputs. It is similar to ObjectType except that it's fields have no args or resolve options and their type must be input type.","title":"Input Object Type Definition"},{"location":"type-definitions/inputs/#writing-input-object-types","text":"In graphql-php Input Object Type is an instance of GraphQL\\Type\\Definition\\InputObjectType (or one of its subclasses) which accepts configuration array in its constructor: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\InputObjectType; $filters = new InputObjectType([ 'name' => 'StoryFiltersInput', 'fields' => [ 'author' => [ 'type' => Type::id(), 'description' => 'Only show stories with this author id' ], 'popular' => [ 'type' => Type::boolean(), 'description' => 'Only show popular stories (liked by several people)' ], 'tags' => [ 'type' => Type::listOf(Type::string()), 'description' => 'Only show stories which contain all of those tags' ] ] ]); Every field may be of other InputObjectType (thus complex hierarchies of inputs are possible)","title":"Writing Input Object Types"},{"location":"type-definitions/inputs/#configuration-options","text":"The constructor of InputObjectType accepts an array with the following options: Option Type Notes name string Required. Unique name of this object type within Schema fields array or callable Required . An array describing object fields or callable returning such an array (see below). description string Plain-text description of this type for clients (e.g. used by GraphiQL for auto-generated documentation) parseValue callable(array<string, mixed>): mixed Converts incoming values from their array representation to something else (e.g. a value object) Every field is an array with following entries: Option Type Notes name string Required. Name of the input field. When not set - inferred from fields array key type Type Required. Instance of one of Input Types ( Scalar , Enum , InputObjectType + any combination of those with nonNull and listOf modifiers) description string Plain-text description of this input field for clients (e.g. used by GraphiQL for auto-generated documentation) defaultValue scalar Default value of this input field. Use the internal value if specifying a default for an enum type","title":"Configuration options"},{"location":"type-definitions/inputs/#using-input-object-type","text":"In the example above we defined our InputObjectType. Now let's use it in one of field arguments: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $queryType = new ObjectType([ 'name' => 'Query', 'fields' => [ 'stories' => [ 'type' => Type::listOf($storyType), 'args' => [ 'filters' => [ 'type' => $filters, 'defaultValue' => [ 'popular' => true ] ] ], 'resolve' => fn ($rootValue, array $args): array => DataSource::filterStories($args['filters']), ] ] ]); (note that you can define defaultValue for fields with complex inputs as associative array). Then GraphQL query could include filters as literal value: { stories(filters: { author: \"1\", popular: false }) } Or as query variable: query ($filters: StoryFiltersInput!) { stories(filters: $filters) } $variables = [ 'filters' => [ \"author\" => \"1\", \"popular\" => false ] ]; graphql-php will validate the input against your InputObjectType definition and pass it to your resolver as $args['filters']","title":"Using Input Object Type"},{"location":"type-definitions/inputs/#converting-input-object-array-to-value-object","text":"If you want more type safety you can choose to parse the input array into a value object. use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\InputObjectType; final class StoryFiltersInput { public string $author; public ?bool $popular; public array $tags; public function __construct(string $author, ?bool $popular, array $tags) { $this->author = $author; $this->popular = $popular; $this->tag = $tag; } } $filters = new InputObjectType([ 'name' => 'StoryFiltersInput', 'fields' => [ 'author' => [ 'type' => Type::nonNull(Type::string()), ], 'popular' => [ 'type' => Type::boolean(), ], 'tags' => [ 'type' => Type::nonNull(Type::listOf(Type::string())), ] ], 'parseValue' => fn(array $values) => new StoryFiltersInput( $values['author'], $values['popular'] ?? null, $values['tags'] ), ]); The value of $args['filters'] will now be an instance of StoryFiltersInput . The incoming values are converted using a depth-first traversal. Thus, nested input values will be passed through their respective parseValue functions before the parent receives their value.","title":"Converting input object array to value object"},{"location":"type-definitions/interfaces/","text":"Interface Type Definition \u00b6 An Interface is an abstract type that includes a certain set of fields that a type must include to implement the interface. Writing Interface Types \u00b6 In graphql-php interface type is an instance of GraphQL\\Type\\Definition\\InterfaceType (or one of its subclasses) which accepts configuration array in a constructor: use GraphQL\\Type\\Definition\\InterfaceType; use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\Type; $character = new InterfaceType([ 'name' => 'Character', 'description' => 'A character in the Star Wars Trilogy', 'fields' => [ 'id' => [ 'type' => Type::nonNull(Type::string()), 'description' => 'The id of the character.', ], 'name' => [ 'type' => Type::string(), 'description' => 'The name of the character.' ] ], 'resolveType' => function ($value): ObjectType { switch ($value->type ?? null) { case 'human': return MyTypes::human(); case 'droid': return MyTypes::droid(); default: throw new Exception(\"Unknown Character type: {$value->type ?? null}\"); } } ]); This example uses inline style for Interface definition, but you can also use inheritance or schema definition language . Configuration options \u00b6 The constructor of InterfaceType accepts an array. Below is a full list of allowed options: Option Type Notes name string Required. Unique name of this interface type within Schema fields array Required. List of fields required to be defined by interface implementors. Same as Fields for Object Type description string Plain-text description of this type for clients (e.g. used by GraphiQL for auto-generated documentation) resolveType callback function ($value, $context, ResolveInfo $info) Receives $value from resolver of the parent field and returns concrete interface implementor for this $value . Implementing interface \u00b6 To implement the Interface simply add it to interfaces array of Object Type definition: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $humanType = new ObjectType([ 'name' => 'Human', 'fields' => [ 'id' => [ 'type' => Type::nonNull(Type::string()), 'description' => 'The id of the character.', ], 'name' => [ 'type' => Type::string(), 'description' => 'The name of the character.' ] ], 'interfaces' => [ $character ] ]); Note that Object Type must include all fields of interface with exact same types (including nonNull specification) and arguments. The only exception is when object's field type is more specific than the type of this field defined in interface (see Covariant return types for interface fields below) Covariant return types for interface fields \u00b6 Object types implementing interface may change the field type to more specific. Example: interface A { field1: A } type B implements A { field1: B } Sharing Interface fields \u00b6 Since every Object Type implementing an Interface must have the same set of fields - it often makes sense to reuse field definitions of Interface in Object Types: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $humanType = new ObjectType([ 'name' => 'Human', 'interfaces' => [ $character ], 'fields' => [ $character->getField('id'), $character->getField('name'), [ 'name' => 'height', 'type' => Type::float(), ], ] ]); In this case, field definitions are created only once (as a part of Interface Type) and then reused by all interface implementors. It can save several microseconds and kilobytes + ensures that field definitions of Interface and implementors are always in sync. Yet it creates a problem with the resolution of such fields. There are two ways how shared fields could be resolved: If field resolution algorithm is the same for all Interface implementors - you can simply add resolve option to field definition in Interface itself. If field resolution varies for different implementations - you can specify resolveField option in Object Type config and handle field resolutions there (Note: resolve option in field definition has precedence over resolveField option in object type definition) Interface role in data fetching \u00b6 The only responsibility of interface in Data Fetching process is to return concrete Object Type for given $value in resolveType . Then resolution of fields is delegated to resolvers of this concrete Object Type. If a resolveType option is omitted, graphql-php will loop through all interface implementors and use their isTypeOf callback to pick the first suitable one. This is obviously less efficient than single resolveType call. So it is recommended to define resolveType whenever possible. Prevent invisible types \u00b6 When object types that implement an interface are not directly referenced by a field, they cannot be discovered during schema introspection. For example: type Query { animal: Animal } interface Animal {...} type Cat implements Animal {...} type Dog implements Animal {...} In this example, Cat and Dog would be considered invisible types. Querying the animal field would fail, since no possible implementing types for Animal can be found. There are two possible solutions: Add fields that reference the invisible types directly, e.g.: graphql type Query { dog: Dog cat: Cat } Pass the invisible types during schema construction, e.g.: new GraphQLSchema([ 'query' => ..., 'types' => [$cat, $dog] ]);","title":"Interfaces"},{"location":"type-definitions/interfaces/#interface-type-definition","text":"An Interface is an abstract type that includes a certain set of fields that a type must include to implement the interface.","title":"Interface Type Definition"},{"location":"type-definitions/interfaces/#writing-interface-types","text":"In graphql-php interface type is an instance of GraphQL\\Type\\Definition\\InterfaceType (or one of its subclasses) which accepts configuration array in a constructor: use GraphQL\\Type\\Definition\\InterfaceType; use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\Type; $character = new InterfaceType([ 'name' => 'Character', 'description' => 'A character in the Star Wars Trilogy', 'fields' => [ 'id' => [ 'type' => Type::nonNull(Type::string()), 'description' => 'The id of the character.', ], 'name' => [ 'type' => Type::string(), 'description' => 'The name of the character.' ] ], 'resolveType' => function ($value): ObjectType { switch ($value->type ?? null) { case 'human': return MyTypes::human(); case 'droid': return MyTypes::droid(); default: throw new Exception(\"Unknown Character type: {$value->type ?? null}\"); } } ]); This example uses inline style for Interface definition, but you can also use inheritance or schema definition language .","title":"Writing Interface Types"},{"location":"type-definitions/interfaces/#configuration-options","text":"The constructor of InterfaceType accepts an array. Below is a full list of allowed options: Option Type Notes name string Required. Unique name of this interface type within Schema fields array Required. List of fields required to be defined by interface implementors. Same as Fields for Object Type description string Plain-text description of this type for clients (e.g. used by GraphiQL for auto-generated documentation) resolveType callback function ($value, $context, ResolveInfo $info) Receives $value from resolver of the parent field and returns concrete interface implementor for this $value .","title":"Configuration options"},{"location":"type-definitions/interfaces/#implementing-interface","text":"To implement the Interface simply add it to interfaces array of Object Type definition: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $humanType = new ObjectType([ 'name' => 'Human', 'fields' => [ 'id' => [ 'type' => Type::nonNull(Type::string()), 'description' => 'The id of the character.', ], 'name' => [ 'type' => Type::string(), 'description' => 'The name of the character.' ] ], 'interfaces' => [ $character ] ]); Note that Object Type must include all fields of interface with exact same types (including nonNull specification) and arguments. The only exception is when object's field type is more specific than the type of this field defined in interface (see Covariant return types for interface fields below)","title":"Implementing interface"},{"location":"type-definitions/interfaces/#covariant-return-types-for-interface-fields","text":"Object types implementing interface may change the field type to more specific. Example: interface A { field1: A } type B implements A { field1: B }","title":"Covariant return types for interface fields"},{"location":"type-definitions/interfaces/#sharing-interface-fields","text":"Since every Object Type implementing an Interface must have the same set of fields - it often makes sense to reuse field definitions of Interface in Object Types: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $humanType = new ObjectType([ 'name' => 'Human', 'interfaces' => [ $character ], 'fields' => [ $character->getField('id'), $character->getField('name'), [ 'name' => 'height', 'type' => Type::float(), ], ] ]); In this case, field definitions are created only once (as a part of Interface Type) and then reused by all interface implementors. It can save several microseconds and kilobytes + ensures that field definitions of Interface and implementors are always in sync. Yet it creates a problem with the resolution of such fields. There are two ways how shared fields could be resolved: If field resolution algorithm is the same for all Interface implementors - you can simply add resolve option to field definition in Interface itself. If field resolution varies for different implementations - you can specify resolveField option in Object Type config and handle field resolutions there (Note: resolve option in field definition has precedence over resolveField option in object type definition)","title":"Sharing Interface fields"},{"location":"type-definitions/interfaces/#interface-role-in-data-fetching","text":"The only responsibility of interface in Data Fetching process is to return concrete Object Type for given $value in resolveType . Then resolution of fields is delegated to resolvers of this concrete Object Type. If a resolveType option is omitted, graphql-php will loop through all interface implementors and use their isTypeOf callback to pick the first suitable one. This is obviously less efficient than single resolveType call. So it is recommended to define resolveType whenever possible.","title":"Interface role in data fetching"},{"location":"type-definitions/interfaces/#prevent-invisible-types","text":"When object types that implement an interface are not directly referenced by a field, they cannot be discovered during schema introspection. For example: type Query { animal: Animal } interface Animal {...} type Cat implements Animal {...} type Dog implements Animal {...} In this example, Cat and Dog would be considered invisible types. Querying the animal field would fail, since no possible implementing types for Animal can be found. There are two possible solutions: Add fields that reference the invisible types directly, e.g.: graphql type Query { dog: Dog cat: Cat } Pass the invisible types during schema construction, e.g.: new GraphQLSchema([ 'query' => ..., 'types' => [$cat, $dog] ]);","title":"Prevent invisible types"},{"location":"type-definitions/lists-and-nonnulls/","text":"Lists \u00b6 graphql-php provides built-in support for lists. In order to create list type - wrap existing type with GraphQL\\Type\\Definition\\Type::listOf() modifier: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $userType = new ObjectType([ 'name' => 'User', 'fields' => [ 'emails' => [ 'type' => Type::listOf(Type::string()), 'resolve' => fn (): array => [ 'jon@example.com', 'jonny@example.com' ], ] ] ]); Resolvers for such fields are expected to return array or instance of PHP's built-in Traversable interface ( null is allowed by default too). If returned value is not of one of these types - graphql-php will add an error to result and set the field value to null (only if the field is nullable, see below for non-null fields). Non-Nulls \u00b6 By default, every field or argument can have a null value. To indicate the value must be non-null use the GraphQL\\Type\\Definition\\Type::nonNull() modifier: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $humanType = new ObjectType([ 'name' => 'User', 'fields' => [ 'id' => [ 'type' => Type::nonNull(Type::id()), 'resolve' => fn (): string => uniqid(), ], 'emails' => [ 'type' => Type::nonNull(Type::listOf(Type::string())), 'resolve' => fn (): array => [ 'jon@example.com', 'jonny@example.com' ], ] ] ]); If resolver of non-null field returns null , graphql-php will add an error to result and exclude the whole object from the output (an error will bubble to first nullable parent field which will be set to null ). Read the section on Data Fetching for details.","title":"Lists and Non-Nulls"},{"location":"type-definitions/lists-and-nonnulls/#lists","text":"graphql-php provides built-in support for lists. In order to create list type - wrap existing type with GraphQL\\Type\\Definition\\Type::listOf() modifier: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $userType = new ObjectType([ 'name' => 'User', 'fields' => [ 'emails' => [ 'type' => Type::listOf(Type::string()), 'resolve' => fn (): array => [ 'jon@example.com', 'jonny@example.com' ], ] ] ]); Resolvers for such fields are expected to return array or instance of PHP's built-in Traversable interface ( null is allowed by default too). If returned value is not of one of these types - graphql-php will add an error to result and set the field value to null (only if the field is nullable, see below for non-null fields).","title":"Lists"},{"location":"type-definitions/lists-and-nonnulls/#non-nulls","text":"By default, every field or argument can have a null value. To indicate the value must be non-null use the GraphQL\\Type\\Definition\\Type::nonNull() modifier: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $humanType = new ObjectType([ 'name' => 'User', 'fields' => [ 'id' => [ 'type' => Type::nonNull(Type::id()), 'resolve' => fn (): string => uniqid(), ], 'emails' => [ 'type' => Type::nonNull(Type::listOf(Type::string())), 'resolve' => fn (): array => [ 'jon@example.com', 'jonny@example.com' ], ] ] ]); If resolver of non-null field returns null , graphql-php will add an error to result and exclude the whole object from the output (an error will bubble to first nullable parent field which will be set to null ). Read the section on Data Fetching for details.","title":"Non-Nulls"},{"location":"type-definitions/object-types/","text":"Object Type Definition \u00b6 Object Type is the most frequently used primitive in a typical GraphQL application. Conceptually Object Type is a collection of Fields. Each field, in turn, has its own type which allows building complex hierarchies. Writing Object Types \u00b6 In graphql-php object type is an instance of GraphQL\\Type\\Definition\\ObjectType (or one of its subclasses) which accepts a configuration array in its constructor: use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\Type; use GraphQL\\Examples\\Blog\\Data\\DataSource; use GraphQL\\Examples\\Blog\\Data\\Story; $userType = new ObjectType([ 'name' => 'User', 'description' => 'Our blog visitor', 'fields' => [ 'firstName' => [ 'type' => Type::string(), 'description' => 'User first name' ], 'email' => Type::string() ] ]); $blogStory = new ObjectType([ 'name' => 'Story', 'fields' => [ 'body' => Type::string(), 'author' => [ 'type' => $userType, 'description' => 'Story author', 'resolve' => fn (Story $blogStory): ?User => DataSource::findUser($blogStory->authorId), ], 'likes' => [ 'type' => Type::listOf($userType), 'description' => 'List of users who liked the story', 'args' => [ 'limit' => [ 'type' => Type::int(), 'description' => 'Limit the number of recent likes returned', 'defaultValue' => 10 ] ], 'resolve' => fn (Story $blogStory, array $args): array => DataSource::findLikes($blogStory->id, $args['limit']), ] ] ]); This example uses inline style for Object Type definitions, but you can also use inheritance or schema definition language . Configuration options \u00b6 Option Type Notes name string Required. Unique name of this object type within Schema fields array or callable Required . An array describing object fields or callable returning such an array. See field configuration options section below for expected structure of each array entry. See also the section on Circular types for an explanation of when to use callable for this option. description string Plain-text description of this type for clients (e.g. used by GraphiQL for auto-generated documentation) interfaces array or callable List of interfaces implemented by this type or callable returning such a list. See Interface Types for details. See also the section on Circular types for an explanation of when to use callable for this option. isTypeOf callable function ($value, $context, ResolveInfo $info): bool Expected to return true if $value qualifies for this type (see section about Abstract Type Resolution for explanation). resolveField callable function ($value, array $args, $context, ResolveInfo $info): mixed Given the $value of this type, it is expected to return value for a field defined in $info->fieldName . A good place to define a type-specific strategy for field resolution. See section on Data Fetching for details. Field configuration options \u00b6 Option Type Notes name string Required. Name of the field. When not set - inferred from fields array key (read about shorthand field definition below) type Type Required. An instance of internal or custom type. Note: type must be represented by a single instance within one schema (see also lazy loading of types ) args array An array describing any number of possible field arguments, each element being an array. See field argument configuration options . resolve callable function ($objectValue, array $args, $context, ResolveInfo $info): mixed Given the $objectValue of this type, it is expected to return actual value of the current field. See section on Data Fetching for details complexity callable function (int $childrenComplexity, array $args): int Used to restrict query complexity. The feature is disabled by default, read about Security to use it. description string Plain-text description of this field for clients (e.g. used by GraphiQL for auto-generated documentation) deprecationReason string Text describing why this field is deprecated. When not empty - field will not be returned by introspection queries (unless forced) Field argument configuration options \u00b6 Option Type Notes name string Required. Name of the argument. When not set - inferred from args array key type Type Required. Instance of one of Input Types ( scalar , enum , InputObjectType + any combination of those with nonNull and listOf modifiers) description string Plain-text description of this argument for clients (e.g. used by GraphiQL for auto-generated documentation) defaultValue scalar Default value for this argument. Use the internal value if specifying a default for an enum type Shorthand field definitions \u00b6 Fields can be also defined in shorthand notation (with only name and type options): 'fields' => [ 'id' => Type::id(), 'fieldName' => $fieldType ] which is equivalent of: 'fields' => [ 'id' => ['type' => Type::id()], 'fieldName' => ['type' => $fieldName] ] which is in turn equivalent of the full form: 'fields' => [ ['name' => 'id', 'type' => Type::id()], ['name' => 'fieldName', 'type' => $fieldName] ] Same shorthand notation applies to field arguments as well. Recurring and circular types \u00b6 Almost all real-world applications contain recurring or circular types. Think user friends or nested comments for example. graphql-php allows such types, but you have to use callable in option fields (and/or interfaces ). For example: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $userType = new ObjectType([ 'name' => 'User', 'fields' => function () use (&$userType): array { return [ 'email' => [ 'type' => Type::string() ], 'friends' => [ 'type' => Type::listOf($userType) ] ]; }, ]); Same example for inheritance style of type definitions using a type registry (see lazy loading of types ): use GraphQL\\Type\\Definition\\ListOfType; use GraphQL\\Type\\Definition\\ScalarType; use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; class UserType extends ObjectType { public function __construct() { parent::__construct([ 'fields' => [ 'email' => fn (): ScalarType => MyTypes::string(), 'friends' => fn (): ListOfType => MyTypes::listOf(MyTypes::user()) ], ]); } } class MyTypes { private static UserType $user; public static function user(): UserType { return self::$user ??= new UserType(); } public static function string(): ScalarType { return Type::string(); } public static function listOf($type): ListOfType { return Type::listOf($type); } } Field Resolution \u00b6 Field resolution is the primary mechanism in graphql-php for returning actual data for your fields. It is implemented using resolveField callable in type definition or resolve callable in field definition (which has precedence). Read the section on Data Fetching for a complete description of this process. Custom Metadata \u00b6 All types in graphql-php accept configuration array. In some cases, you may be interested in passing your own metadata for type or field definition. graphql-php preserves original configuration array in every type or field instance in public property $config . Use it to implement app-level mappings and definitions.","title":"Object Types"},{"location":"type-definitions/object-types/#object-type-definition","text":"Object Type is the most frequently used primitive in a typical GraphQL application. Conceptually Object Type is a collection of Fields. Each field, in turn, has its own type which allows building complex hierarchies.","title":"Object Type Definition"},{"location":"type-definitions/object-types/#writing-object-types","text":"In graphql-php object type is an instance of GraphQL\\Type\\Definition\\ObjectType (or one of its subclasses) which accepts a configuration array in its constructor: use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\Type; use GraphQL\\Examples\\Blog\\Data\\DataSource; use GraphQL\\Examples\\Blog\\Data\\Story; $userType = new ObjectType([ 'name' => 'User', 'description' => 'Our blog visitor', 'fields' => [ 'firstName' => [ 'type' => Type::string(), 'description' => 'User first name' ], 'email' => Type::string() ] ]); $blogStory = new ObjectType([ 'name' => 'Story', 'fields' => [ 'body' => Type::string(), 'author' => [ 'type' => $userType, 'description' => 'Story author', 'resolve' => fn (Story $blogStory): ?User => DataSource::findUser($blogStory->authorId), ], 'likes' => [ 'type' => Type::listOf($userType), 'description' => 'List of users who liked the story', 'args' => [ 'limit' => [ 'type' => Type::int(), 'description' => 'Limit the number of recent likes returned', 'defaultValue' => 10 ] ], 'resolve' => fn (Story $blogStory, array $args): array => DataSource::findLikes($blogStory->id, $args['limit']), ] ] ]); This example uses inline style for Object Type definitions, but you can also use inheritance or schema definition language .","title":"Writing Object Types"},{"location":"type-definitions/object-types/#configuration-options","text":"Option Type Notes name string Required. Unique name of this object type within Schema fields array or callable Required . An array describing object fields or callable returning such an array. See field configuration options section below for expected structure of each array entry. See also the section on Circular types for an explanation of when to use callable for this option. description string Plain-text description of this type for clients (e.g. used by GraphiQL for auto-generated documentation) interfaces array or callable List of interfaces implemented by this type or callable returning such a list. See Interface Types for details. See also the section on Circular types for an explanation of when to use callable for this option. isTypeOf callable function ($value, $context, ResolveInfo $info): bool Expected to return true if $value qualifies for this type (see section about Abstract Type Resolution for explanation). resolveField callable function ($value, array $args, $context, ResolveInfo $info): mixed Given the $value of this type, it is expected to return value for a field defined in $info->fieldName . A good place to define a type-specific strategy for field resolution. See section on Data Fetching for details.","title":"Configuration options"},{"location":"type-definitions/object-types/#field-configuration-options","text":"Option Type Notes name string Required. Name of the field. When not set - inferred from fields array key (read about shorthand field definition below) type Type Required. An instance of internal or custom type. Note: type must be represented by a single instance within one schema (see also lazy loading of types ) args array An array describing any number of possible field arguments, each element being an array. See field argument configuration options . resolve callable function ($objectValue, array $args, $context, ResolveInfo $info): mixed Given the $objectValue of this type, it is expected to return actual value of the current field. See section on Data Fetching for details complexity callable function (int $childrenComplexity, array $args): int Used to restrict query complexity. The feature is disabled by default, read about Security to use it. description string Plain-text description of this field for clients (e.g. used by GraphiQL for auto-generated documentation) deprecationReason string Text describing why this field is deprecated. When not empty - field will not be returned by introspection queries (unless forced)","title":"Field configuration options"},{"location":"type-definitions/object-types/#field-argument-configuration-options","text":"Option Type Notes name string Required. Name of the argument. When not set - inferred from args array key type Type Required. Instance of one of Input Types ( scalar , enum , InputObjectType + any combination of those with nonNull and listOf modifiers) description string Plain-text description of this argument for clients (e.g. used by GraphiQL for auto-generated documentation) defaultValue scalar Default value for this argument. Use the internal value if specifying a default for an enum type","title":"Field argument configuration options"},{"location":"type-definitions/object-types/#shorthand-field-definitions","text":"Fields can be also defined in shorthand notation (with only name and type options): 'fields' => [ 'id' => Type::id(), 'fieldName' => $fieldType ] which is equivalent of: 'fields' => [ 'id' => ['type' => Type::id()], 'fieldName' => ['type' => $fieldName] ] which is in turn equivalent of the full form: 'fields' => [ ['name' => 'id', 'type' => Type::id()], ['name' => 'fieldName', 'type' => $fieldName] ] Same shorthand notation applies to field arguments as well.","title":"Shorthand field definitions"},{"location":"type-definitions/object-types/#recurring-and-circular-types","text":"Almost all real-world applications contain recurring or circular types. Think user friends or nested comments for example. graphql-php allows such types, but you have to use callable in option fields (and/or interfaces ). For example: use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; $userType = new ObjectType([ 'name' => 'User', 'fields' => function () use (&$userType): array { return [ 'email' => [ 'type' => Type::string() ], 'friends' => [ 'type' => Type::listOf($userType) ] ]; }, ]); Same example for inheritance style of type definitions using a type registry (see lazy loading of types ): use GraphQL\\Type\\Definition\\ListOfType; use GraphQL\\Type\\Definition\\ScalarType; use GraphQL\\Type\\Definition\\Type; use GraphQL\\Type\\Definition\\ObjectType; class UserType extends ObjectType { public function __construct() { parent::__construct([ 'fields' => [ 'email' => fn (): ScalarType => MyTypes::string(), 'friends' => fn (): ListOfType => MyTypes::listOf(MyTypes::user()) ], ]); } } class MyTypes { private static UserType $user; public static function user(): UserType { return self::$user ??= new UserType(); } public static function string(): ScalarType { return Type::string(); } public static function listOf($type): ListOfType { return Type::listOf($type); } }","title":"Recurring and circular types"},{"location":"type-definitions/object-types/#field-resolution","text":"Field resolution is the primary mechanism in graphql-php for returning actual data for your fields. It is implemented using resolveField callable in type definition or resolve callable in field definition (which has precedence). Read the section on Data Fetching for a complete description of this process.","title":"Field Resolution"},{"location":"type-definitions/object-types/#custom-metadata","text":"All types in graphql-php accept configuration array. In some cases, you may be interested in passing your own metadata for type or field definition. graphql-php preserves original configuration array in every type or field instance in public property $config . Use it to implement app-level mappings and definitions.","title":"Custom Metadata"},{"location":"type-definitions/scalars/","text":"Scalar Type Definition \u00b6 Scalar types represent primitive leaf values in a GraphQL type system. When object fields have to resolve to some concrete data, that's where the scalar types come in. Built-in Scalar Types \u00b6 The GraphQL specification describes several built-in scalar types. In graphql-php they are exposed as static methods of the class GraphQL\\Type\\Definition\\Type : use GraphQL\\Type\\Definition\\Type; // Built-in Scalar types: Type::string(); // String type Type::int(); // Int type Type::float(); // Float type Type::boolean(); // Boolean type Type::id(); // ID type Those methods return instances of a subclass of GraphQL\\Type\\Definition\\ScalarType . Use them directly in type definitions or wrapped in a type registry (see lazy loading of types ). Writing Custom Scalar Types \u00b6 In addition to built-in scalars, you can define your own scalar types with additional validation. Typical examples of such types are Email , Date , Url , etc. In order to implement your own type, you must understand how scalars are handled in GraphQL. GraphQL deals with scalars in the following cases: Convert the internal representation of a value, returned by your app (e.g. stored in a database or hardcoded in the source code), to a serialized representation included in the response. Convert an input value , passed by a client in variables along with a GraphQL query, to its internal representation used in your application. Convert an input literal value , hardcoded in a GraphQL query (e.g. field argument value), to its internal representation used in your application. Those cases are covered by the methods serialize , parseValue and parseLiteral of the abstract class ScalarType respectively. Here is an example of a simple Email type: use GraphQL\\Error\\Error; use GraphQL\\Error\\InvariantViolation; use GraphQL\\Language\\AST\\StringValueNode; use GraphQL\\Type\\Definition\\ScalarType; use GraphQL\\Utils\\Utils; class EmailType extends ScalarType { // Note: name can be omitted. In this case it will be inferred from class name // (suffix \"Type\" will be dropped) public string $name = 'Email'; public function serialize($value) { if (!filter_var($value, FILTER_VALIDATE_EMAIL)) { throw new InvariantViolation(\"Could not serialize following value as email: \" . Utils::printSafe($value)); } return $this->parseValue($value); } public function parseValue($value) { if (!filter_var($value, FILTER_VALIDATE_EMAIL)) { throw new Error(\"Cannot represent following value as email: \" . Utils::printSafeJson($value)); } return $value; } public function parseLiteral(Node $valueNode, ?array $variables = null) { // Throw GraphQL\\Error\\Error vs \\UnexpectedValueException to locate the error in the query if (!$valueNode instanceof StringValueNode) { throw new Error('Query error: Can only parse strings got: ' . $valueNode->kind, [$valueNode]); } if (!filter_var($valueNode->value, FILTER_VALIDATE_EMAIL)) { throw new Error(\"Not a valid email\", [$valueNode]); } return $valueNode->value; } } Or with inline style: use GraphQL\\Type\\Definition\\CustomScalarType; $emailType = new CustomScalarType([ 'name' => 'Email', 'serialize' => static function ($value) {/* See function body above */}, 'parseValue' => static function ($value) {/* See function body above */}, 'parseLiteral' => static function (Node $valueNode, ?array $variables = null) {/* See function body above */}, ]); Keep in mind the passed functions will be called statically, so a passed in callable such as [Foo::class, 'bar'] should only reference static class methods.","title":"Scalars"},{"location":"type-definitions/scalars/#scalar-type-definition","text":"Scalar types represent primitive leaf values in a GraphQL type system. When object fields have to resolve to some concrete data, that's where the scalar types come in.","title":"Scalar Type Definition"},{"location":"type-definitions/scalars/#built-in-scalar-types","text":"The GraphQL specification describes several built-in scalar types. In graphql-php they are exposed as static methods of the class GraphQL\\Type\\Definition\\Type : use GraphQL\\Type\\Definition\\Type; // Built-in Scalar types: Type::string(); // String type Type::int(); // Int type Type::float(); // Float type Type::boolean(); // Boolean type Type::id(); // ID type Those methods return instances of a subclass of GraphQL\\Type\\Definition\\ScalarType . Use them directly in type definitions or wrapped in a type registry (see lazy loading of types ).","title":"Built-in Scalar Types"},{"location":"type-definitions/scalars/#writing-custom-scalar-types","text":"In addition to built-in scalars, you can define your own scalar types with additional validation. Typical examples of such types are Email , Date , Url , etc. In order to implement your own type, you must understand how scalars are handled in GraphQL. GraphQL deals with scalars in the following cases: Convert the internal representation of a value, returned by your app (e.g. stored in a database or hardcoded in the source code), to a serialized representation included in the response. Convert an input value , passed by a client in variables along with a GraphQL query, to its internal representation used in your application. Convert an input literal value , hardcoded in a GraphQL query (e.g. field argument value), to its internal representation used in your application. Those cases are covered by the methods serialize , parseValue and parseLiteral of the abstract class ScalarType respectively. Here is an example of a simple Email type: use GraphQL\\Error\\Error; use GraphQL\\Error\\InvariantViolation; use GraphQL\\Language\\AST\\StringValueNode; use GraphQL\\Type\\Definition\\ScalarType; use GraphQL\\Utils\\Utils; class EmailType extends ScalarType { // Note: name can be omitted. In this case it will be inferred from class name // (suffix \"Type\" will be dropped) public string $name = 'Email'; public function serialize($value) { if (!filter_var($value, FILTER_VALIDATE_EMAIL)) { throw new InvariantViolation(\"Could not serialize following value as email: \" . Utils::printSafe($value)); } return $this->parseValue($value); } public function parseValue($value) { if (!filter_var($value, FILTER_VALIDATE_EMAIL)) { throw new Error(\"Cannot represent following value as email: \" . Utils::printSafeJson($value)); } return $value; } public function parseLiteral(Node $valueNode, ?array $variables = null) { // Throw GraphQL\\Error\\Error vs \\UnexpectedValueException to locate the error in the query if (!$valueNode instanceof StringValueNode) { throw new Error('Query error: Can only parse strings got: ' . $valueNode->kind, [$valueNode]); } if (!filter_var($valueNode->value, FILTER_VALIDATE_EMAIL)) { throw new Error(\"Not a valid email\", [$valueNode]); } return $valueNode->value; } } Or with inline style: use GraphQL\\Type\\Definition\\CustomScalarType; $emailType = new CustomScalarType([ 'name' => 'Email', 'serialize' => static function ($value) {/* See function body above */}, 'parseValue' => static function ($value) {/* See function body above */}, 'parseLiteral' => static function (Node $valueNode, ?array $variables = null) {/* See function body above */}, ]); Keep in mind the passed functions will be called statically, so a passed in callable such as [Foo::class, 'bar'] should only reference static class methods.","title":"Writing Custom Scalar Types"},{"location":"type-definitions/unions/","text":"Union Type Definition \u00b6 A Union is an abstract type that simply enumerates other Object Types. The value of Union Type is actually a value of one of included Object Types. Writing Union Types \u00b6 In graphql-php union type is an instance of GraphQL\\Type\\Definition\\UnionType (or one of its subclasses) which accepts configuration array in a constructor: use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\UnionType; $searchResultType = new UnionType([ 'name' => 'SearchResult', 'types' => [ MyTypes::story(), MyTypes::user() ], 'resolveType' => function ($value): ObjectType { switch ($value->type ?? null) { case 'story': return MyTypes::story(); case 'user': return MyTypes::user(); default: throw new Exception(\"Unexpected SearchResult type: {$value->type ?? null}\"); } }, ]); This example uses inline style for Union definition, but you can also use inheritance or schema definition language . Configuration options \u00b6 The constructor of UnionType accepts an array. Below is a full list of allowed options: Option Type Notes name string Required. Unique name of this interface type within Schema types array Required. List of Object Types included in this Union. Note that you can't create a Union type out of Interfaces or other Unions. description string Plain-text description of this type for clients (e.g. used by GraphiQL for auto-generated documentation) resolveType callback function ($value, $context, ResolveInfo $info): ObjectType Receives $value from resolver of the parent field and returns concrete Object Type for this $value .","title":"Unions"},{"location":"type-definitions/unions/#union-type-definition","text":"A Union is an abstract type that simply enumerates other Object Types. The value of Union Type is actually a value of one of included Object Types.","title":"Union Type Definition"},{"location":"type-definitions/unions/#writing-union-types","text":"In graphql-php union type is an instance of GraphQL\\Type\\Definition\\UnionType (or one of its subclasses) which accepts configuration array in a constructor: use GraphQL\\Type\\Definition\\ObjectType; use GraphQL\\Type\\Definition\\UnionType; $searchResultType = new UnionType([ 'name' => 'SearchResult', 'types' => [ MyTypes::story(), MyTypes::user() ], 'resolveType' => function ($value): ObjectType { switch ($value->type ?? null) { case 'story': return MyTypes::story(); case 'user': return MyTypes::user(); default: throw new Exception(\"Unexpected SearchResult type: {$value->type ?? null}\"); } }, ]); This example uses inline style for Union definition, but you can also use inheritance or schema definition language .","title":"Writing Union Types"},{"location":"type-definitions/unions/#configuration-options","text":"The constructor of UnionType accepts an array. Below is a full list of allowed options: Option Type Notes name string Required. Unique name of this interface type within Schema types array Required. List of Object Types included in this Union. Note that you can't create a Union type out of Interfaces or other Unions. description string Plain-text description of this type for clients (e.g. used by GraphiQL for auto-generated documentation) resolveType callback function ($value, $context, ResolveInfo $info): ObjectType Receives $value from resolver of the parent field and returns concrete Object Type for this $value .","title":"Configuration options"}]}